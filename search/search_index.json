{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SASjs CLI Documentation \u00b6 The SASjs Command-Line-Interface is a swiss-army knife with a flexible set of options and utilities for Dev Ops on SAS Viya, SAS 9 EBI, and SASjs Server Core functionalities: Creation of a SAS GIT repository in an 'opinionated' way. Compilation each service, including all the dependent macros / macro variables and pre / post code. Build - creation of the master SAS deployment, including build macros, macro variables, and pre/post code. Deployment - execute an array of local scripts and remote SAS programs to create your app on the SAS Server. Test - create unit test for macros, jobs & services, check your test coverage, generate test reports Documentation - generate a doxygen site with data lineage, homepage, and project logo, all from the sasjsconfig.json file There is also a feature to let you deploy your frontend as a streaming app , bypassing the need to access the SAS Web Server. Commands \u00b6 Command Description add Provides a series of prompts used to define a SAS target along with the relevant connection details (if SAS Viya) auth Provides the prompts for authentication against a SAS target (SAS 9 or Viya) build takes all of the input jobs and services and creates a build pack cbd A shortcut to compile , build and deploy your project with one command! compile Extracts all the dependencies and input programs for each service / job and includes them in a single file ready for deployment context List, export, create, edit, and delete SAS Compute contexts create Initialise a SASjs repository, either in plain form or using a range of templates deploy Perform the actual deployment of a SASjs project to a SAS Server location doc Generate HTML documentation based on the Doxygen headers used in the SAS Macros, Programs, Jobs & Services. flow SAS job scheduler that takes a JSON file as input, and submit all the jobs sequentially, logging the results to an output CSV file folder Management of logical Viya folders job Manage & Execute SAS Jobs lint Lint your SAS code and identify commmon problems / undesirable coding practices request Execute SASjs web services from the commandline run Run arbitrary SAS code directly from the terminal (or commandline session) servicepack The SASjs Service Pack is a collection of services and folder objects. The servicepack command lets you deploy them easily snippets Generate a snippets file for autocompletion of your SAS Macros in VS Code test Execute SAS unit tests and collect results in json/csv formats together with logs","title":"Home"},{"location":"#sasjs-cli-documentation","text":"The SASjs Command-Line-Interface is a swiss-army knife with a flexible set of options and utilities for Dev Ops on SAS Viya, SAS 9 EBI, and SASjs Server Core functionalities: Creation of a SAS GIT repository in an 'opinionated' way. Compilation each service, including all the dependent macros / macro variables and pre / post code. Build - creation of the master SAS deployment, including build macros, macro variables, and pre/post code. Deployment - execute an array of local scripts and remote SAS programs to create your app on the SAS Server. Test - create unit test for macros, jobs & services, check your test coverage, generate test reports Documentation - generate a doxygen site with data lineage, homepage, and project logo, all from the sasjsconfig.json file There is also a feature to let you deploy your frontend as a streaming app , bypassing the need to access the SAS Web Server.","title":"SASjs CLI Documentation"},{"location":"#commands","text":"Command Description add Provides a series of prompts used to define a SAS target along with the relevant connection details (if SAS Viya) auth Provides the prompts for authentication against a SAS target (SAS 9 or Viya) build takes all of the input jobs and services and creates a build pack cbd A shortcut to compile , build and deploy your project with one command! compile Extracts all the dependencies and input programs for each service / job and includes them in a single file ready for deployment context List, export, create, edit, and delete SAS Compute contexts create Initialise a SASjs repository, either in plain form or using a range of templates deploy Perform the actual deployment of a SASjs project to a SAS Server location doc Generate HTML documentation based on the Doxygen headers used in the SAS Macros, Programs, Jobs & Services. flow SAS job scheduler that takes a JSON file as input, and submit all the jobs sequentially, logging the results to an output CSV file folder Management of logical Viya folders job Manage & Execute SAS Jobs lint Lint your SAS code and identify commmon problems / undesirable coding practices request Execute SASjs web services from the commandline run Run arbitrary SAS code directly from the terminal (or commandline session) servicepack The SASjs Service Pack is a collection of services and folder objects. The servicepack command lets you deploy them easily snippets Generate a snippets file for autocompletion of your SAS Macros in VS Code test Execute SAS unit tests and collect results in json/csv formats together with logs","title":"Commands"},{"location":"add/","text":"sasjs add \u00b6 The sasjs add command provides a series of prompts used to define a SAS target along with the relevant connection details (if SAS Viya). Syntax \u00b6 sasjs add sasjs add cred -t targetname # add creds for existing target Description \u00b6 Local or Global Config \u00b6 The first prompt requests scope. If Local is chosen, the target configuration will be added in the /sasjs/sasjsconfig.json file, and any credentials (eg tokens) will be saved in a .env.[targetName] file in the current SASjs project directory. If Global is chosen, the target configuration will be added to a .sasjsrc file in the users home directory. The sasjs command will look for a target here if executed outside of a SASjs project. Server Type \u00b6 The second prompt requests a server type. Options: SAS Viya - works on 3.5 and 4 SAS 9 - to execute code on SAS 9 SASjs - for deploying to SASjs Server Target Name \u00b6 Choose a name for your target. Nearly every SASjs command will take this as input, so you might want to keep it short. Target Server URL \u00b6 This is the protocol / servername / port of your target, for instance: https://sas.sasjs.com:8080 SAS Viya Specific \u00b6 If SAS Viya was chosen as the server type you will be prompted for a Viya Client ID and secret - this is used for connecting to the SAS Viya REST APIs. To autogenerate these you can also check out the Viya Token Generator . Once you have entered the client and secret, you will be given a link - click this to generate the authorisation code (one time step). The token will eventually expire - the majority of commands will show the link again at this point to refresh the token. To avoid this happening in batch, be sure your token remains valid, eg by setting a longer expiry period. SAS 9 Specific \u00b6 If SAS 9 was chosen as the serverType then the server name should be chosen (eg SASApp) and the metadata repository in which to deploy the SAS Web Services. Default is Foundation.","title":"sasjs add"},{"location":"add/#sasjs-add","text":"The sasjs add command provides a series of prompts used to define a SAS target along with the relevant connection details (if SAS Viya).","title":"sasjs add"},{"location":"add/#syntax","text":"sasjs add sasjs add cred -t targetname # add creds for existing target","title":"Syntax"},{"location":"add/#description","text":"","title":"Description"},{"location":"add/#local-or-global-config","text":"The first prompt requests scope. If Local is chosen, the target configuration will be added in the /sasjs/sasjsconfig.json file, and any credentials (eg tokens) will be saved in a .env.[targetName] file in the current SASjs project directory. If Global is chosen, the target configuration will be added to a .sasjsrc file in the users home directory. The sasjs command will look for a target here if executed outside of a SASjs project.","title":"Local or Global Config"},{"location":"add/#server-type","text":"The second prompt requests a server type. Options: SAS Viya - works on 3.5 and 4 SAS 9 - to execute code on SAS 9 SASjs - for deploying to SASjs Server","title":"Server Type"},{"location":"add/#target-name","text":"Choose a name for your target. Nearly every SASjs command will take this as input, so you might want to keep it short.","title":"Target Name"},{"location":"add/#target-server-url","text":"This is the protocol / servername / port of your target, for instance: https://sas.sasjs.com:8080","title":"Target Server URL"},{"location":"add/#sas-viya-specific","text":"If SAS Viya was chosen as the server type you will be prompted for a Viya Client ID and secret - this is used for connecting to the SAS Viya REST APIs. To autogenerate these you can also check out the Viya Token Generator . Once you have entered the client and secret, you will be given a link - click this to generate the authorisation code (one time step). The token will eventually expire - the majority of commands will show the link again at this point to refresh the token. To avoid this happening in batch, be sure your token remains valid, eg by setting a longer expiry period.","title":"SAS Viya Specific"},{"location":"add/#sas-9-specific","text":"If SAS 9 was chosen as the serverType then the server name should be chosen (eg SASApp) and the metadata repository in which to deploy the SAS Web Services. Default is Foundation.","title":"SAS 9 Specific"},{"location":"artefacts/","text":"SASjs Artefacts \u00b6 SASjs projects are full of files with .sas extensions. With the exception of tests, the only way to tell them apart is to start from the sasjs/sasjsconfig.json file. Each file type is described below. Primary Artefacts \u00b6 The three Primary Artefacts are Job, Service, and Test. These artefacts are compiled, added to a build pack, and deployed to SAS. Job \u00b6 A SASjs Job is a .sas program found in a directory listed in the jobFolders array of the jobConfig object. Where there are jobFolders at both target and root level in the sasjsconfig.json file, the subdirectory/jobname.sas files at target level will take precedence. Jobs are not expected to write to _webout and so are not compiled with the %webout() macro and it's dependencies. Jobs are always created in a /jobs/ folder under the target appLoc. A Job may contain: Data Inputs / Outputs - used to generate the data lineage Macros - listed under <h4> SAS Macros </h4> SAS Includes - listed under <h4> SAS Includes </h4> Binary Files - under <h4> Binary Files </h4> Service \u00b6 A SASjs Service is a .sas program found in a directory listed in the serviceFolders array of the serviceConfig object. Where there are serviceFolders at both target and root level in the sasjsconfig.json file, the subdirectory/servicename.sas files at target level will take precedence. Services are expected to write to _webout and so are compiled along with the %webout() macro and dependencies. Services are always created in a /services/ folder under the target appLoc. A Service may contain: Service Inputs / Outputs - helpful for the JS developers Macros - listed under <h4> SAS Macros </h4> SAS Includes - listed under <h4> SAS Includes </h4> Binary Files - under <h4> Binary Files </h4> Test \u00b6 A SASjs Test is a .test.sas (or .test.[integer].sas) program found in ANY of the macroFolders , serviceFolders or jobFolders arrays. Tests are compiled like services (with %webout() and dependencies) so that test results can be returned in the output JSON. Tests are always created in a /tests/ folder under the target appLoc as follows: $appLoc/tests/macros -> Macro tests $appLoc/tests/jobs -> Job tests $appLoc/tests/services -> Service tests A test may contain: Macros - listed under <h4> SAS Macros </h4> SAS Includes - listed under <h4> SAS Includes </h4> Binary Files - under <h4> Binary Files </h4> Secondary Artefacts \u00b6 SAS Macros \u00b6 Macro dependencies can be specified in the following artefacts: Jobs Services Tests Macros (extracted recursively) initProgram termProgram They are NOT compiled from SAS Includes or Binary Files. To add a set of macros to a compiled file, just add the following in the header of the source file (artefact): <h4> SAS Macros </h4> @li macro1.sas @li macro2.sas During compilation, these macros will be sourced from the following locations (in this order): target-level macroFolders array in the sasjsconfig.json file root-level macroFolders array in the sasjsconfig.json file SASjs Core under node_modules/@sasjs/core SASjs Core under node_modules/@sasjs/cli/node_modules/@sasjs/core SASjs Core from the GLOBAL install of the SASjs CLI As soon as a macro is found, the search stops. So if an mf_nobs.sas macro was placed in a directory from the root-level macroFolders array, then the same-named definition would NOT be taken from SASjs Core. If a macro is not found then the compilation will immediately fail. To avoid continually re-scanning the locations above, macros are added to an internal object (compileTree) as they are found, along with their dependents and source folder location. After compilation this object is exported to sasjsbuild/compileTree.json . The compiled file does not contain duplicate macros. When compiling each Job / Service / Test, a distinct list of 'top level' macro names are taken from any initProgram and termProgram definitions, in addition to the %webout() dependencies if a Service or Test. The header of each macro is removed in order to reduce the overall compiled file size. SAS Includes \u00b6 Whilst macro definitions can be easily copy pasted into the beginning of a job, arbitrary SAS code files cannot (as they are executed immediately rather than compiled into a macro catalog). To enable arbitrary SAS code files (SAS Includes), the compile process will wrap the code in data step put '(source code);'; statements and assign a user-provided fileref to enable the code to be easily %inc 'd at the preferred point of execution. SAS Include dependencies can be specified in the following artefacts: Jobs Services Tests They are NOT compiled from macros or other SAS Includes. To add a set of SAS Includes to a compiled file, add the following in the source file (artefact) header: <h4> SAS Includes </h4> @li somefile.sas MYREF @li anotherfile.ddl MOJFREF During compilation, the locations below will be searched for files named somefile.sas and anotherfile.ddl : target-level programFolders array in the sasjsconfig.json file root-level programFolders array in the sasjsconfig.json file When the file is found, it is wrapped in put statements and added to the compiled file, along with a filename statement corresponding to the user-provided fileref (eg MYREF or MOJREF ). To run this code as part of your Job, Service, or Test - just execute as follows: %inc MYREF; %inc MOJREF; Binary Files \u00b6 In rare cases you may wish to embed non textual content into your Job / Service / Test - such as Excel, Zip, Images, even video. This is all possible thanks to a common technique known as Base64 encoding. This allows ANY binary content to be represented as a text string - with the caveat that the encoded file will be at least 33% larger (4 bytes used for every 3 bytes of input). The compilation process both base64 encodes the source file AND wraps it in put statements with a corresponding fileref for developer use. Binary Files can be specified in the following artefacts: Job Service Test They are not compiled from Macros or SAS Includes. To add a set of Binary Files to a compiled file, add the following in the source file (artefact) header: <h4> Binary Files </h4> @li myfile.zip MYZIP @li base.xlsx XL During compilation, the locations below will be searched for files named myfile.zip and base.xlsx : target-level binaryFolders array in the sasjsconfig.json file root-level programFolders array in the sasjsconfig.json file When the file is found, it is base64 encoded then wrapped in put statements and added to the compiled file, along with a filename statement corresponding to the user-provided fileref (eg MYZIP or XL ). To run this code as part of your Job, Service, or Test - just execute, for example, as follows: %mp_unzip (ziploc= \"%sysfunc(pathname(MYZIP))\" ,outdir= &sasjswork ) initProgram \u00b6 The initProgram attribute is found in the following objects: jobConfig serviceConfig testConfig Any Macros in the initProgram are compiled along with those in the termProgram , the Job / Service / Test itself, and the webout() macros (if a Service or Test). The initProgram code itself is inserted without modification into the compiled file right before the main Job / Service / Test code. Only one initProgram may be used (target level or root level), and it is always applied to ALL instances of the particular type (ie Job / Service / Test). termProgram \u00b6 The termProgram attribute is found in the following objects: jobConfig serviceConfig testConfig Any Macros in the termProgram are compiled along with those in the initProgram , the Job / Service / Test itself, and the webout() macros (if a Service or Test). The termProgram code itself is inserted without modification into the compiled file right after the main Job / Service / Test code. Only one termProgram may be used (target level or root level), and it is always applied to ALL instances of the particular type (ie Job / Service / Test).","title":"Artefacts"},{"location":"artefacts/#sasjs-artefacts","text":"SASjs projects are full of files with .sas extensions. With the exception of tests, the only way to tell them apart is to start from the sasjs/sasjsconfig.json file. Each file type is described below.","title":"SASjs Artefacts"},{"location":"artefacts/#primary-artefacts","text":"The three Primary Artefacts are Job, Service, and Test. These artefacts are compiled, added to a build pack, and deployed to SAS.","title":"Primary Artefacts"},{"location":"artefacts/#job","text":"A SASjs Job is a .sas program found in a directory listed in the jobFolders array of the jobConfig object. Where there are jobFolders at both target and root level in the sasjsconfig.json file, the subdirectory/jobname.sas files at target level will take precedence. Jobs are not expected to write to _webout and so are not compiled with the %webout() macro and it's dependencies. Jobs are always created in a /jobs/ folder under the target appLoc. A Job may contain: Data Inputs / Outputs - used to generate the data lineage Macros - listed under <h4> SAS Macros </h4> SAS Includes - listed under <h4> SAS Includes </h4> Binary Files - under <h4> Binary Files </h4>","title":"Job"},{"location":"artefacts/#service","text":"A SASjs Service is a .sas program found in a directory listed in the serviceFolders array of the serviceConfig object. Where there are serviceFolders at both target and root level in the sasjsconfig.json file, the subdirectory/servicename.sas files at target level will take precedence. Services are expected to write to _webout and so are compiled along with the %webout() macro and dependencies. Services are always created in a /services/ folder under the target appLoc. A Service may contain: Service Inputs / Outputs - helpful for the JS developers Macros - listed under <h4> SAS Macros </h4> SAS Includes - listed under <h4> SAS Includes </h4> Binary Files - under <h4> Binary Files </h4>","title":"Service"},{"location":"artefacts/#test","text":"A SASjs Test is a .test.sas (or .test.[integer].sas) program found in ANY of the macroFolders , serviceFolders or jobFolders arrays. Tests are compiled like services (with %webout() and dependencies) so that test results can be returned in the output JSON. Tests are always created in a /tests/ folder under the target appLoc as follows: $appLoc/tests/macros -> Macro tests $appLoc/tests/jobs -> Job tests $appLoc/tests/services -> Service tests A test may contain: Macros - listed under <h4> SAS Macros </h4> SAS Includes - listed under <h4> SAS Includes </h4> Binary Files - under <h4> Binary Files </h4>","title":"Test"},{"location":"artefacts/#secondary-artefacts","text":"","title":"Secondary Artefacts"},{"location":"artefacts/#sas-macros","text":"Macro dependencies can be specified in the following artefacts: Jobs Services Tests Macros (extracted recursively) initProgram termProgram They are NOT compiled from SAS Includes or Binary Files. To add a set of macros to a compiled file, just add the following in the header of the source file (artefact): <h4> SAS Macros </h4> @li macro1.sas @li macro2.sas During compilation, these macros will be sourced from the following locations (in this order): target-level macroFolders array in the sasjsconfig.json file root-level macroFolders array in the sasjsconfig.json file SASjs Core under node_modules/@sasjs/core SASjs Core under node_modules/@sasjs/cli/node_modules/@sasjs/core SASjs Core from the GLOBAL install of the SASjs CLI As soon as a macro is found, the search stops. So if an mf_nobs.sas macro was placed in a directory from the root-level macroFolders array, then the same-named definition would NOT be taken from SASjs Core. If a macro is not found then the compilation will immediately fail. To avoid continually re-scanning the locations above, macros are added to an internal object (compileTree) as they are found, along with their dependents and source folder location. After compilation this object is exported to sasjsbuild/compileTree.json . The compiled file does not contain duplicate macros. When compiling each Job / Service / Test, a distinct list of 'top level' macro names are taken from any initProgram and termProgram definitions, in addition to the %webout() dependencies if a Service or Test. The header of each macro is removed in order to reduce the overall compiled file size.","title":"SAS Macros"},{"location":"artefacts/#sas-includes","text":"Whilst macro definitions can be easily copy pasted into the beginning of a job, arbitrary SAS code files cannot (as they are executed immediately rather than compiled into a macro catalog). To enable arbitrary SAS code files (SAS Includes), the compile process will wrap the code in data step put '(source code);'; statements and assign a user-provided fileref to enable the code to be easily %inc 'd at the preferred point of execution. SAS Include dependencies can be specified in the following artefacts: Jobs Services Tests They are NOT compiled from macros or other SAS Includes. To add a set of SAS Includes to a compiled file, add the following in the source file (artefact) header: <h4> SAS Includes </h4> @li somefile.sas MYREF @li anotherfile.ddl MOJFREF During compilation, the locations below will be searched for files named somefile.sas and anotherfile.ddl : target-level programFolders array in the sasjsconfig.json file root-level programFolders array in the sasjsconfig.json file When the file is found, it is wrapped in put statements and added to the compiled file, along with a filename statement corresponding to the user-provided fileref (eg MYREF or MOJREF ). To run this code as part of your Job, Service, or Test - just execute as follows: %inc MYREF; %inc MOJREF;","title":"SAS Includes"},{"location":"artefacts/#binary-files","text":"In rare cases you may wish to embed non textual content into your Job / Service / Test - such as Excel, Zip, Images, even video. This is all possible thanks to a common technique known as Base64 encoding. This allows ANY binary content to be represented as a text string - with the caveat that the encoded file will be at least 33% larger (4 bytes used for every 3 bytes of input). The compilation process both base64 encodes the source file AND wraps it in put statements with a corresponding fileref for developer use. Binary Files can be specified in the following artefacts: Job Service Test They are not compiled from Macros or SAS Includes. To add a set of Binary Files to a compiled file, add the following in the source file (artefact) header: <h4> Binary Files </h4> @li myfile.zip MYZIP @li base.xlsx XL During compilation, the locations below will be searched for files named myfile.zip and base.xlsx : target-level binaryFolders array in the sasjsconfig.json file root-level programFolders array in the sasjsconfig.json file When the file is found, it is base64 encoded then wrapped in put statements and added to the compiled file, along with a filename statement corresponding to the user-provided fileref (eg MYZIP or XL ). To run this code as part of your Job, Service, or Test - just execute, for example, as follows: %mp_unzip (ziploc= \"%sysfunc(pathname(MYZIP))\" ,outdir= &sasjswork )","title":"Binary Files"},{"location":"artefacts/#initprogram","text":"The initProgram attribute is found in the following objects: jobConfig serviceConfig testConfig Any Macros in the initProgram are compiled along with those in the termProgram , the Job / Service / Test itself, and the webout() macros (if a Service or Test). The initProgram code itself is inserted without modification into the compiled file right before the main Job / Service / Test code. Only one initProgram may be used (target level or root level), and it is always applied to ALL instances of the particular type (ie Job / Service / Test).","title":"initProgram"},{"location":"artefacts/#termprogram","text":"The termProgram attribute is found in the following objects: jobConfig serviceConfig testConfig Any Macros in the termProgram are compiled along with those in the initProgram , the Job / Service / Test itself, and the webout() macros (if a Service or Test). The termProgram code itself is inserted without modification into the compiled file right after the main Job / Service / Test code. Only one termProgram may be used (target level or root level), and it is always applied to ALL instances of the particular type (ie Job / Service / Test).","title":"termProgram"},{"location":"auth/","text":"sasjs auth \u00b6 The sasjs auth command authenticates against a predefined SAS target . The following commands make use of authentication: sasjs run sasjs job execute sasjs flow sasjs fs sasjs request sasjs deploy sasjs test sasjs folder The sasjs auth command is an alias for sasjs add cred - and it is integrated also into the sasjs add command (for adding a new target). Prerequisites \u00b6 Before using this command, you will need to: install the SASjs CLI add a deployment target. Syntax \u00b6 sasjs auth [additional arguments] Additional arguments may include: --target (alias -t ) - the target environment in which to deploy the services. If not specified, the defaultTarget will be used, as defined in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. Scope \u00b6 Targets can have local (to a project) or global (to a user) scope . For a local target, credentials are stored in a .env.[target name] file. To have one file that covers all (local) targets you can rename this file to .env . All published SASjs projects (and templates) already include this file in the .gitignore file, if you are deploying to your own existing project you should do the same - to prevent accidentally pushing credentials to source control. For global targets the credentials are stored in the .sasjsrc file in the users home directory. Server Type \u00b6 The authentication approach taken will depend on the serverType (SASVIYA, SAS9 or SASJS). SAS Viya Authentication \u00b6 To authenticate with SAS Viya you will need an administrator to provide a CLIENT and SECRET with authorization_code grant type (SASjs does not support password authentication grant type). Further information on this topic is available here . After you provide the client / secret, you are given a link which you must click to obtain the authorisation code. Be sure to select any scopes (such as openid) if presented. Once you provide the authorisation code, the ACESS_TOKEN and REFRESH_TOKEN are saved and used for further connection requests. If the ACCESS_TOKEN expires (by default after 12 hours) the REFRESH_TOKEN will be used automatically to update, until it also expires (by default after 30 days). At this point, you will need to run sasjs auth once again. SAS 9 Authentication \u00b6 SAS 9 authentication requires a username and password. We strongly recommend the use of SAS encoded passwords (method=sas003 and above), however - to enable this you will first need to make a server side change (to the AllowEncodedPassword property) as follows: Log on to SAS\u00ae Management Console. Select Application Management. Navigate to Configuration Manager \u25ba Stored Process Web App Select Properties \u25ba Advanced (tab). Click the Add button and define a new property: Property Name: AllowEncodedPassword Property Value: true Click OK Restart the Mid Tier Web Server If the password you provide is not sas-encoded, the command will still work, however you will get health warnings in the log. SASjs Runner \u00b6 SAS 9 operations require the use of a \"runner\" for executing the SAS code generated by the CLI. For security, this runner is always stored in your home directory in metadata. To deploy the runner: /* import the macros */ filename mc url \"https://raw.githubusercontent.com/sasjs/core/main/all.sas\" ; %inc mc; /* create the runner */ filename ft15f001 temp; parmcards4; %macro sasjs_runner(); %if %symexist (_webin_fileref) %then %do ; %inc &_webin_fileref ; %end ; %mend sasjs_runner; %sasjs_runner () ;;;; %mm_createwebservice ( path=/User Folders/ &sysuserid /My Folder/sasjs, name=runner ) SASJS Server Authentication \u00b6 Authentication on SASjs Server is only neccessary in server mode (there is no authentication in desktop mode). The default clientID is clientID1 . TLS Config \u00b6 If the server certificates are set up correctly (full chain) then no additional config is required. However, sometimes when there are self-signed certificates, the following error may occur: unable to verify the first certificate It means that the webserver you are connecting to is misconfigured (certificate chain is incomplete) and did not include the intermediate certificate. To resolve, you may step through the following. Replace \"4gl.viyacloud.sas.com\" with your own SAS server URL. # 1. grap the logcertfile openssl s_client -connect 4gl.viyacloud.sas.com:443 -servername 4gl.viyacloud.sas.com | tee logcertfile # 2. obtain the issuer URI openssl x509 -in logcertfile -noout -text | grep -i \"issuer\" # 3. Fetch CRT from URI above # for this case, using \"http://cacerts.digicert.com/DigiCertTLSRSASHA2562020CA1-1.crt\" curl --output intermediate.crt http://cacerts.digicert.com/DigiCertTLSRSASHA2562020CA1-1.crt # 4. extract intermediate.pem from the CRT file openssl x509 -inform DER -in intermediate.crt -out intermediate.pem -text If you don't have a well-formed URI in step 3 above, you might try step 4 directly on the CRT if you are able to find it. One option is to look in the browser (click the padlock) or check the filesystem - here is a possible location on a Viya platform: /opt/sas/viya/config/etc/SASSecurityCertificateFramework/tls/certs . Further information on this topic is available in this StackOverflow thread: https://stackoverflow.com/a/60020493 Once you have the PEM file it can be added to the httpsAgentOptions configuration as follows: For testing, if you are running internally and you trust the target server, you may consider the following property in your sasjs/sasjsconfig.json file to temporarily ignore the certificate errors. However, this is not a recommended approach. \"httpsAgentOptions\" : { \"allowInsecureRequests\" : true }","title":"sasjs auth"},{"location":"auth/#sasjs-auth","text":"The sasjs auth command authenticates against a predefined SAS target . The following commands make use of authentication: sasjs run sasjs job execute sasjs flow sasjs fs sasjs request sasjs deploy sasjs test sasjs folder The sasjs auth command is an alias for sasjs add cred - and it is integrated also into the sasjs add command (for adding a new target).","title":"sasjs auth"},{"location":"auth/#prerequisites","text":"Before using this command, you will need to: install the SASjs CLI add a deployment target.","title":"Prerequisites"},{"location":"auth/#syntax","text":"sasjs auth [additional arguments] Additional arguments may include: --target (alias -t ) - the target environment in which to deploy the services. If not specified, the defaultTarget will be used, as defined in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file.","title":"Syntax"},{"location":"auth/#scope","text":"Targets can have local (to a project) or global (to a user) scope . For a local target, credentials are stored in a .env.[target name] file. To have one file that covers all (local) targets you can rename this file to .env . All published SASjs projects (and templates) already include this file in the .gitignore file, if you are deploying to your own existing project you should do the same - to prevent accidentally pushing credentials to source control. For global targets the credentials are stored in the .sasjsrc file in the users home directory.","title":"Scope"},{"location":"auth/#server-type","text":"The authentication approach taken will depend on the serverType (SASVIYA, SAS9 or SASJS).","title":"Server Type"},{"location":"auth/#sas-viya-authentication","text":"To authenticate with SAS Viya you will need an administrator to provide a CLIENT and SECRET with authorization_code grant type (SASjs does not support password authentication grant type). Further information on this topic is available here . After you provide the client / secret, you are given a link which you must click to obtain the authorisation code. Be sure to select any scopes (such as openid) if presented. Once you provide the authorisation code, the ACESS_TOKEN and REFRESH_TOKEN are saved and used for further connection requests. If the ACCESS_TOKEN expires (by default after 12 hours) the REFRESH_TOKEN will be used automatically to update, until it also expires (by default after 30 days). At this point, you will need to run sasjs auth once again.","title":"SAS Viya Authentication"},{"location":"auth/#sas-9-authentication","text":"SAS 9 authentication requires a username and password. We strongly recommend the use of SAS encoded passwords (method=sas003 and above), however - to enable this you will first need to make a server side change (to the AllowEncodedPassword property) as follows: Log on to SAS\u00ae Management Console. Select Application Management. Navigate to Configuration Manager \u25ba Stored Process Web App Select Properties \u25ba Advanced (tab). Click the Add button and define a new property: Property Name: AllowEncodedPassword Property Value: true Click OK Restart the Mid Tier Web Server If the password you provide is not sas-encoded, the command will still work, however you will get health warnings in the log.","title":"SAS 9 Authentication"},{"location":"auth/#sasjs-runner","text":"SAS 9 operations require the use of a \"runner\" for executing the SAS code generated by the CLI. For security, this runner is always stored in your home directory in metadata. To deploy the runner: /* import the macros */ filename mc url \"https://raw.githubusercontent.com/sasjs/core/main/all.sas\" ; %inc mc; /* create the runner */ filename ft15f001 temp; parmcards4; %macro sasjs_runner(); %if %symexist (_webin_fileref) %then %do ; %inc &_webin_fileref ; %end ; %mend sasjs_runner; %sasjs_runner () ;;;; %mm_createwebservice ( path=/User Folders/ &sysuserid /My Folder/sasjs, name=runner )","title":"SASjs Runner"},{"location":"auth/#sasjs-server-authentication","text":"Authentication on SASjs Server is only neccessary in server mode (there is no authentication in desktop mode). The default clientID is clientID1 .","title":"SASJS Server Authentication"},{"location":"auth/#tls-config","text":"If the server certificates are set up correctly (full chain) then no additional config is required. However, sometimes when there are self-signed certificates, the following error may occur: unable to verify the first certificate It means that the webserver you are connecting to is misconfigured (certificate chain is incomplete) and did not include the intermediate certificate. To resolve, you may step through the following. Replace \"4gl.viyacloud.sas.com\" with your own SAS server URL. # 1. grap the logcertfile openssl s_client -connect 4gl.viyacloud.sas.com:443 -servername 4gl.viyacloud.sas.com | tee logcertfile # 2. obtain the issuer URI openssl x509 -in logcertfile -noout -text | grep -i \"issuer\" # 3. Fetch CRT from URI above # for this case, using \"http://cacerts.digicert.com/DigiCertTLSRSASHA2562020CA1-1.crt\" curl --output intermediate.crt http://cacerts.digicert.com/DigiCertTLSRSASHA2562020CA1-1.crt # 4. extract intermediate.pem from the CRT file openssl x509 -inform DER -in intermediate.crt -out intermediate.pem -text If you don't have a well-formed URI in step 3 above, you might try step 4 directly on the CRT if you are able to find it. One option is to look in the browser (click the padlock) or check the filesystem - here is a possible location on a Viya platform: /opt/sas/viya/config/etc/SASSecurityCertificateFramework/tls/certs . Further information on this topic is available in this StackOverflow thread: https://stackoverflow.com/a/60020493 Once you have the PEM file it can be added to the httpsAgentOptions configuration as follows: For testing, if you are running internally and you trust the target server, you may consider the following property in your sasjs/sasjsconfig.json file to temporarily ignore the certificate errors. However, this is not a recommended approach. \"httpsAgentOptions\" : { \"allowInsecureRequests\" : true }","title":"TLS Config"},{"location":"build/","text":"sasjs build \u00b6 For ease of project deployment, sasjs build brings all the compiled Jobs / Services / Tests together into a single file. Actually, 3 files, as follows: sasjsbuild/target.json - used to deploy using the APIs in Viya or SASjs Server sasjsbuild/target.json.zip - used for faster uploads of large payloads in SASjs Server sasjsbuild/target.sas - used to create the project in SAS 9 or Viya (when no access token is available) The filename corresponds to the target name unless buildOutputFileName is specified. If a jobs or services folder does not exist in the temporary sasjsbuild folder, then the sasjs compile step is also executed. The alias to run both compile and build steps is sasjs cb . The benefit of having a seperate command to prepare the build artefacts (rather than bundling it into sasjs compile ) is that you can then modify the compiled outputs to ensure you have the build you want - for example, removing tests for a production deploy. If you don't need such changes, then you can just run sasjs cb as a shortcut for both sasjs compile and sasjs build . Target.JSON Build Artefact \u00b6 The JSON file is used by the sasjs deploy command for the SASVIYA serverType to create all the necessary folders, jobs, services & tests (and streamed web apps) in the target appLoc . Target.json.ZIP Build Artefact \u00b6 This is simply a zipped version of the target.json file, and is used when uploading apps or deploying projects to SASjs Server . Target.SAS Build Artefact \u00b6 The generated SAS program can be executed directly in SAS 9 or SAS Viya to create all the jobs/services/tests programmatically. This is especially useful for Viya developers who are unable to obtain a client / secret. For SAS 9 it is the primary deployment method. SAS 9 Build Script \u00b6 The SAS 9 Build Program can be executed in EG or SAS Studio, and also automatically as part of sasjs deploy when deployServicePack is true. You just need to have a runner in your metadata home directory, and to provide credentials using sasjs auth . Viya Build Script \u00b6 The .sas file can be executed in SASStudioV without modification as proc http will use the oauth_bearer=sas_services option to authenticate to the APIs. This is the way to deploy SASjs projects when you do not have a CLIENT or SECRET. Running Viya Build Script in Non-Viya-Enabled SAS sessions \u00b6 If for some reason you need to run the Viya build script in a non SPRE / Viya-enabled session (eg in SAS 9 or SASjs Server) you will need to prepare the access token - see guidance here: https://cli.sasjs.io/faq/#viya-token-macros Put this access token in a macro variable called ACCESS_TOKEN and it will be used by proc http in the core macros by reference to the access_token_var= keyword parameter of each viya macro (the ones that start with mv* ). Warning Saving security tokens in project repositories, especially if they are committed to source control, is a security risk - as anyone with access can use them to make modifications on the Viya platform. If you are running Viya code in non Viya-enabled SAS environments using the ACCESS_TOKEN approach described above, be sure to use a secure mechanism such as %inc from a secure directory, or another approved mechanism for securing these kinds of variables. Avoid writing Access Tokens to log files.","title":"sasjs build"},{"location":"build/#sasjs-build","text":"For ease of project deployment, sasjs build brings all the compiled Jobs / Services / Tests together into a single file. Actually, 3 files, as follows: sasjsbuild/target.json - used to deploy using the APIs in Viya or SASjs Server sasjsbuild/target.json.zip - used for faster uploads of large payloads in SASjs Server sasjsbuild/target.sas - used to create the project in SAS 9 or Viya (when no access token is available) The filename corresponds to the target name unless buildOutputFileName is specified. If a jobs or services folder does not exist in the temporary sasjsbuild folder, then the sasjs compile step is also executed. The alias to run both compile and build steps is sasjs cb . The benefit of having a seperate command to prepare the build artefacts (rather than bundling it into sasjs compile ) is that you can then modify the compiled outputs to ensure you have the build you want - for example, removing tests for a production deploy. If you don't need such changes, then you can just run sasjs cb as a shortcut for both sasjs compile and sasjs build .","title":"sasjs build"},{"location":"build/#targetjson-build-artefact","text":"The JSON file is used by the sasjs deploy command for the SASVIYA serverType to create all the necessary folders, jobs, services & tests (and streamed web apps) in the target appLoc .","title":"Target.JSON Build Artefact"},{"location":"build/#targetjsonzip-build-artefact","text":"This is simply a zipped version of the target.json file, and is used when uploading apps or deploying projects to SASjs Server .","title":"Target.json.ZIP Build Artefact"},{"location":"build/#targetsas-build-artefact","text":"The generated SAS program can be executed directly in SAS 9 or SAS Viya to create all the jobs/services/tests programmatically. This is especially useful for Viya developers who are unable to obtain a client / secret. For SAS 9 it is the primary deployment method.","title":"Target.SAS Build Artefact"},{"location":"build/#sas-9-build-script","text":"The SAS 9 Build Program can be executed in EG or SAS Studio, and also automatically as part of sasjs deploy when deployServicePack is true. You just need to have a runner in your metadata home directory, and to provide credentials using sasjs auth .","title":"SAS 9 Build Script"},{"location":"build/#viya-build-script","text":"The .sas file can be executed in SASStudioV without modification as proc http will use the oauth_bearer=sas_services option to authenticate to the APIs. This is the way to deploy SASjs projects when you do not have a CLIENT or SECRET.","title":"Viya Build Script"},{"location":"build/#running-viya-build-script-in-non-viya-enabled-sas-sessions","text":"If for some reason you need to run the Viya build script in a non SPRE / Viya-enabled session (eg in SAS 9 or SASjs Server) you will need to prepare the access token - see guidance here: https://cli.sasjs.io/faq/#viya-token-macros Put this access token in a macro variable called ACCESS_TOKEN and it will be used by proc http in the core macros by reference to the access_token_var= keyword parameter of each viya macro (the ones that start with mv* ). Warning Saving security tokens in project repositories, especially if they are committed to source control, is a security risk - as anyone with access can use them to make modifications on the Viya platform. If you are running Viya code in non Viya-enabled SAS environments using the ACCESS_TOKEN approach described above, be sure to use a secure mechanism such as %inc from a secure directory, or another approved mechanism for securing these kinds of variables. Avoid writing Access Tokens to log files.","title":"Running Viya Build Script in Non-Viya-Enabled SAS sessions"},{"location":"cbd/","text":"sasjs cbd \u00b6 The sasjs cbd command is actually an alias for three commands, namely: sasjs compile sasjs build sasjs deploy If you are changing a source file, then it is typically necessary to run all three commands in order to get your project deployed, so sasjs cbd is a handy shortcut. Sometimes though you need to run separately - for example, say you would like to deploy to a production but without the tests. You could run sasjs compile first (which includes the tests), then rm -rf sasjsbuild/tests , then sasjs build (without tests) and finally sasjs deploy . Or perhaps you have run sasjs cbd but the process failed during deployment due to an authorisation issue. You can simply run sasjs auth (to re-authorise) and then sasjs deploy (to avoid the recompilation and rebuild). The following diagram illustrates the end to end sasjs cbd process. Notes: Source code is organised however you like within the GIT repository sasjs compile pulls all the dependencies to create self-contained jobs, services & tests These live within a .gitignore 'd folder called sasjsbuild in the project repo sasjs build takes all the compiled artefacts to create a \"build pack\" (in .sas and .json formats) This build pack can now be used to easily deploy the project to the target SAS environment.","title":"sasjs cbd"},{"location":"cbd/#sasjs-cbd","text":"The sasjs cbd command is actually an alias for three commands, namely: sasjs compile sasjs build sasjs deploy If you are changing a source file, then it is typically necessary to run all three commands in order to get your project deployed, so sasjs cbd is a handy shortcut. Sometimes though you need to run separately - for example, say you would like to deploy to a production but without the tests. You could run sasjs compile first (which includes the tests), then rm -rf sasjsbuild/tests , then sasjs build (without tests) and finally sasjs deploy . Or perhaps you have run sasjs cbd but the process failed during deployment due to an authorisation issue. You can simply run sasjs auth (to re-authorise) and then sasjs deploy (to avoid the recompilation and rebuild). The following diagram illustrates the end to end sasjs cbd process. Notes: Source code is organised however you like within the GIT repository sasjs compile pulls all the dependencies to create self-contained jobs, services & tests These live within a .gitignore 'd folder called sasjsbuild in the project repo sasjs build takes all the compiled artefacts to create a \"build pack\" (in .sas and .json formats) This build pack can now be used to easily deploy the project to the target SAS environment.","title":"sasjs cbd"},{"location":"compile/","text":"sasjs compile \u00b6 Overview \u00b6 Compilation in SASjs is driven from the sasjs/sasjsconfig.json file, and results in the creation of a single self-contained SAS program per JOB / SERVICE / TEST. The benefits of working with compiled files are severalfold: Build on ONE platform, deploy to THREE (Viya, EBI, Base) Elimination of SAS Catalogs for macros / programs Elimination of filesystem dependency for code Resilient and Highly Portable Applications Consistent Performance Easy to debug & test sasjs compile can be applied to a single file, or more commonly, to all the files in a project. Content is added to each compiled Job/Service/Test in the following order: MacroVars Binary Files Macros Programs initProgram Job/Service/Test termProgram The following diagram illustrates the compilation of a Service (service_xyz.sas) that includes some macro variables, as well as common macro dependencies across the initProgram and termProgram : Notice that only one copy of the macro is inserted, even though it is defined in multiple artefacts. The following diagram illustrates the logic flow when compiling a Primary Artefact : 1. sasjsbuild Folder \u00b6 In every SASjs project, content is split according to whether the file type is Job, Service or Test. For a project that has all three, and has tests covering SAS Macros / Jobs / Tests, the sasjsbuild folder (and ultimately, the remote SAS folder) will contain the following tree: jobs/ services/ tests/jobs/ tests/macros/ tests/services/ Below the above, the immediate child will be the last child of the xxxFolder - eg for a serviceConfig as follows: { \"serviceConfig\" :{ \"serviceFolders\" :[ \"/some/project/location\" ] } } A filepath of /some/project/location/myservice.sas will thus be compiled inside: services/location/myservice.sas . Nested directories are supported. For a filepath of /some/project/location/subfolder/subsubfolder/here.sas the compile location would be: services/location/subfolder/subsubfolder/here.sas . 2. Macro Variables \u00b6 Macro variables are inserted according to the type of the compiled file, ie from one of the following objects: jobConfig serviceConfig testConfig 3. Binary Files \u00b6 Binary Files are converted to a base64 string and wrapped in put statements with a user provided fileref as described here 4. SAS Macros \u00b6 SAS Macros are recursively compiled to ensure there is only one copy of each macro across the initProgram, termProgram, the primary artefact itself, and the webout() macros (if a Service or Test). More info here . 5. SAS Includes \u00b6 SAS Includes are wrapped in put statements and a filename statement is generated with a user provided fileref. More info here . 6. initProgram \u00b6 The initProgram executes right before the main Job / Service / Test. More info here . 7. Source Code \u00b6 This section contains the actual code inside the Job / Service / Test. More info here . Compile Single File \u00b6 When compiling a single file, it is necessary to state whether the file is being compiled is a job, service or test (as these file types are compiled with differing pre-code). Syntax \u00b6 sasjs compile <action> [additional arguments] action can be job or service or test Additional arguments include: --source (alias -s ) - the path/name.ext of the individual source file to compile (as job or service). MANDATORY --target (alias -t ) - The target to use for obtaining the source folders of programs and macros. If it is not specified, the default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. OPTIONAL --output (alias -o ) - path where output of the compiled job or service will be saved. OPTIONAL. If not provided, the output will go to the root of the sasjsbuild folder if in a project ( sasjsbuild would be emptied first), else in the current working directory. sasjs compile job -s sasjs/jobs/admin/somejob -o compiledjobs/folder sasjs c service --source sasjs/services/common/appinit -t myTarget Compile Project \u00b6 Syntax \u00b6 sasjs compile [additional arguments] Additional arguments include: --target (alias -t ) - The target to use for obtaining the source folders of programs and macros. If it is not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. OPTIONAL Examples: sasjs compile sasjs c sasjs c -t someTarget Artefact Compilation \u00b6 From the root of the project, run: sasjs compile . This will cycle through all the Jobs / Services / Tests in the jobFolders / serviceFolders / testFolders arrays in the sasjsconfig.json file, extract all of the dependent Binary Files, SAS Macros, SAS Includes, and create one self-contained file per Job (or Service, or Test) inside the sasjsbuild folder. The self-contained file will also include any initProgram , termProgram and macroVars defined in the relevant config objects. The binaryFolders , macroFolders and programFolders arrays are searched for Binary Files, SAS Macros and SAS Includes (first in the target config, then in the root). The serviceConfig , jobConfig and testConfig objects may have attributes split at either or both target and root level in the sasjsconfig.json file. Tests compilation \u00b6 As part of compilation process test files will be compiled as well. Test configuration should be provided in sasjs/sasjsconfig.json . Test files should be placed in the same folders with services, jobs and macros. Compiled test files will result in sasjsbuild/tests folder under services , jobs or macros subfolder respectively. Tests execution flow will be described in sasjsbuild/testFlow.json file. The testConfig object allows two additional programs to be compiled (as tests): testSetUp - executed once at the beginning of the test run testTearDown - executed once, at the end of the test run SyncFolder Compilation \u00b6 If the syncFolder attribute is set, then the contents of that folder will be simply copied into the sasjsbuild folder. This is useful for providing mocked services (eg in sasjs/server ) or to add arbitrary content to the SAS logical folder tree. Streaming Apps \u00b6 If streamWeb is true , then the index.html file in your webSourcePath is also scanned and any linked JS / CSS files are also compiled into the streamWebFolder folder. The index.html becomes a clickme service in your appLoc SAS folder root. Base64 encoding \u00b6 If you don't have an index.html and you just want to compile arbitrary binary content (such as images, mp3, excel files etc) as base64 services, set the location of the content in assetPaths . All files in the specified folder(s) will be turned into web services.","title":"sasjs compile"},{"location":"compile/#sasjs-compile","text":"","title":"sasjs compile"},{"location":"compile/#overview","text":"Compilation in SASjs is driven from the sasjs/sasjsconfig.json file, and results in the creation of a single self-contained SAS program per JOB / SERVICE / TEST. The benefits of working with compiled files are severalfold: Build on ONE platform, deploy to THREE (Viya, EBI, Base) Elimination of SAS Catalogs for macros / programs Elimination of filesystem dependency for code Resilient and Highly Portable Applications Consistent Performance Easy to debug & test sasjs compile can be applied to a single file, or more commonly, to all the files in a project. Content is added to each compiled Job/Service/Test in the following order: MacroVars Binary Files Macros Programs initProgram Job/Service/Test termProgram The following diagram illustrates the compilation of a Service (service_xyz.sas) that includes some macro variables, as well as common macro dependencies across the initProgram and termProgram : Notice that only one copy of the macro is inserted, even though it is defined in multiple artefacts. The following diagram illustrates the logic flow when compiling a Primary Artefact :","title":"Overview"},{"location":"compile/#1-sasjsbuild-folder","text":"In every SASjs project, content is split according to whether the file type is Job, Service or Test. For a project that has all three, and has tests covering SAS Macros / Jobs / Tests, the sasjsbuild folder (and ultimately, the remote SAS folder) will contain the following tree: jobs/ services/ tests/jobs/ tests/macros/ tests/services/ Below the above, the immediate child will be the last child of the xxxFolder - eg for a serviceConfig as follows: { \"serviceConfig\" :{ \"serviceFolders\" :[ \"/some/project/location\" ] } } A filepath of /some/project/location/myservice.sas will thus be compiled inside: services/location/myservice.sas . Nested directories are supported. For a filepath of /some/project/location/subfolder/subsubfolder/here.sas the compile location would be: services/location/subfolder/subsubfolder/here.sas .","title":"1. sasjsbuild Folder"},{"location":"compile/#2-macro-variables","text":"Macro variables are inserted according to the type of the compiled file, ie from one of the following objects: jobConfig serviceConfig testConfig","title":"2. Macro Variables"},{"location":"compile/#3-binary-files","text":"Binary Files are converted to a base64 string and wrapped in put statements with a user provided fileref as described here","title":"3. Binary Files"},{"location":"compile/#4-sas-macros","text":"SAS Macros are recursively compiled to ensure there is only one copy of each macro across the initProgram, termProgram, the primary artefact itself, and the webout() macros (if a Service or Test). More info here .","title":"4. SAS Macros"},{"location":"compile/#5-sas-includes","text":"SAS Includes are wrapped in put statements and a filename statement is generated with a user provided fileref. More info here .","title":"5. SAS Includes"},{"location":"compile/#6-initprogram","text":"The initProgram executes right before the main Job / Service / Test. More info here .","title":"6. initProgram"},{"location":"compile/#7-source-code","text":"This section contains the actual code inside the Job / Service / Test. More info here .","title":"7. Source Code"},{"location":"compile/#compile-single-file","text":"When compiling a single file, it is necessary to state whether the file is being compiled is a job, service or test (as these file types are compiled with differing pre-code).","title":"Compile Single File"},{"location":"compile/#syntax","text":"sasjs compile <action> [additional arguments] action can be job or service or test Additional arguments include: --source (alias -s ) - the path/name.ext of the individual source file to compile (as job or service). MANDATORY --target (alias -t ) - The target to use for obtaining the source folders of programs and macros. If it is not specified, the default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. OPTIONAL --output (alias -o ) - path where output of the compiled job or service will be saved. OPTIONAL. If not provided, the output will go to the root of the sasjsbuild folder if in a project ( sasjsbuild would be emptied first), else in the current working directory. sasjs compile job -s sasjs/jobs/admin/somejob -o compiledjobs/folder sasjs c service --source sasjs/services/common/appinit -t myTarget","title":"Syntax"},{"location":"compile/#compile-project","text":"","title":"Compile Project"},{"location":"compile/#syntax_1","text":"sasjs compile [additional arguments] Additional arguments include: --target (alias -t ) - The target to use for obtaining the source folders of programs and macros. If it is not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. OPTIONAL Examples: sasjs compile sasjs c sasjs c -t someTarget","title":"Syntax"},{"location":"compile/#artefact-compilation","text":"From the root of the project, run: sasjs compile . This will cycle through all the Jobs / Services / Tests in the jobFolders / serviceFolders / testFolders arrays in the sasjsconfig.json file, extract all of the dependent Binary Files, SAS Macros, SAS Includes, and create one self-contained file per Job (or Service, or Test) inside the sasjsbuild folder. The self-contained file will also include any initProgram , termProgram and macroVars defined in the relevant config objects. The binaryFolders , macroFolders and programFolders arrays are searched for Binary Files, SAS Macros and SAS Includes (first in the target config, then in the root). The serviceConfig , jobConfig and testConfig objects may have attributes split at either or both target and root level in the sasjsconfig.json file.","title":"Artefact Compilation"},{"location":"compile/#tests-compilation","text":"As part of compilation process test files will be compiled as well. Test configuration should be provided in sasjs/sasjsconfig.json . Test files should be placed in the same folders with services, jobs and macros. Compiled test files will result in sasjsbuild/tests folder under services , jobs or macros subfolder respectively. Tests execution flow will be described in sasjsbuild/testFlow.json file. The testConfig object allows two additional programs to be compiled (as tests): testSetUp - executed once at the beginning of the test run testTearDown - executed once, at the end of the test run","title":"Tests compilation"},{"location":"compile/#syncfolder-compilation","text":"If the syncFolder attribute is set, then the contents of that folder will be simply copied into the sasjsbuild folder. This is useful for providing mocked services (eg in sasjs/server ) or to add arbitrary content to the SAS logical folder tree.","title":"SyncFolder Compilation"},{"location":"compile/#streaming-apps","text":"If streamWeb is true , then the index.html file in your webSourcePath is also scanned and any linked JS / CSS files are also compiled into the streamWebFolder folder. The index.html becomes a clickme service in your appLoc SAS folder root.","title":"Streaming Apps"},{"location":"compile/#base64-encoding","text":"If you don't have an index.html and you just want to compile arbitrary binary content (such as images, mp3, excel files etc) as base64 services, set the location of the content in assetPaths . All files in the specified folder(s) will be turned into web services.","title":"Base64 encoding"},{"location":"context/","text":"sasjs context \u00b6 The sasjs context command allows users to list all and export individual Compute Contexts. Administrators may also create, edit and delete contexts. A compute context is used when firing up a new SAS session (it itself inherits from a Launcher Context). Example use cases for this tool: Creating a new compute context as part of a CI/CD deploy Deleting a compute context as part of a tidy up Discovering which compute contexts can actually be used Modifying a compute context, eg to update the autoexec or system account used Prerequisites \u00b6 Before using this command, you will need to install the SASJS CLI and add a deployment target . Syntax \u00b6 sasjs context <action> [additional arguments] Additional arguments include: --source (alias -s ) - the source JSON file to create or edit a compute context. Used in the create and edit actions. --target (alias -t ) - the target environment in which to create the compute context. If not specified, the first target will be used instead. The target can exist either in the local project configuration or in the global .sasjsrc file. Compute Context Structure \u00b6 The create and edit actions use the same JSON structure for adding / modifying contexts. This also matches the context made by the export action, which can be used to provide a template for adding / modifying new contexts. The JSON is defined as follows: { \"name\": \"myNewComputeContext\", \"attributes\": { \"reuseServerProcesses\": true, \"runServerAs\": \"mycasaccount\" }, \"environment\": { \"autoExecLines\": [ \"%put autoexec line 1;\", \"%put autoexect line 2;\" ], \"options\": [ \"-BUFNO 10\", \"-MEMSIZE 4G\" ] }, \"launchContext\": { \"contextName\": \"SAS Job Execution launcher context\" }, \"launchType\": \"service\", } To explain the sections: name - name of the compute context you will create reuseServerProcesses - since Viya 3.5 you can re-use sessions, this improves performance significantly but requires the sessions to run under a system account (defined below) runServerAs - the system account to use when re-using server processes autoExecLines - an array of SAS program lines. These will execute ONCE when the server process is started, so expensive libname assignments could be placed here, speeding up web service response times. options - an array of SAS option settings contextName - the name of the launcher context used to spawn the compute context launchtype - a mandatory parameter, more details here sasjs context create \u00b6 Used to create a new compute context. Syntax \u00b6 sasjs context create -s source.json -t target Usage \u00b6 # create minimal context config cat > ./myContext.json <<'EOL' { \"name\": \"myNewComputeContext\", \"launchContext\": { \"contextName\": \"SAS Job Execution launcher context\" }, \"launchType\": \"service\" } EOL # create the context using the target defined in sasjs add sasjs context create -s ./myContext.json -t myTarget sasjs context delete \u00b6 Used to delete an existing context. No source JSON needed, contextName is used instead. Syntax \u00b6 sasjs context delete <contextName> -t target Usage \u00b6 sasjs context delete myUndesirableComputeContext -t myTarget sasjs context edit \u00b6 Used to edit an existing context Syntax \u00b6 sasjs context edit <contextName> -s source.json -t target Usage \u00b6 # create JSON file with the changes to apply cat > ./myContext.json <<'EOL' { \"name\": \"myRenamedComputeContext\", \"launchContext\": { \"contextName\": \"Some Other launcher context\" }, \"launchType\": \"service\" } EOL # update the context named myComputeContext sasjs context edit myComputeContext -s ./myContext.json -t myTarget sasjs context export \u00b6 Exports specified compute context to contextName.json in the current folder. No source JSON is needed, just provide the contextName . Syntax \u00b6 sasjs context export <contextName> -t target Usage \u00b6 sasjs context export someContext -t myTarget sasjs context list \u00b6 Outputs a list of all accessible and inaccessible contexts. Accessible contexts are discovered by attempting to run %put &=sysuserid; on each context. Syntax \u00b6 sasjs context list -t target Usage \u00b6 sasjs context list -t myTarget","title":"sasjs context"},{"location":"context/#sasjs-context","text":"The sasjs context command allows users to list all and export individual Compute Contexts. Administrators may also create, edit and delete contexts. A compute context is used when firing up a new SAS session (it itself inherits from a Launcher Context). Example use cases for this tool: Creating a new compute context as part of a CI/CD deploy Deleting a compute context as part of a tidy up Discovering which compute contexts can actually be used Modifying a compute context, eg to update the autoexec or system account used","title":"sasjs context"},{"location":"context/#prerequisites","text":"Before using this command, you will need to install the SASJS CLI and add a deployment target .","title":"Prerequisites"},{"location":"context/#syntax","text":"sasjs context <action> [additional arguments] Additional arguments include: --source (alias -s ) - the source JSON file to create or edit a compute context. Used in the create and edit actions. --target (alias -t ) - the target environment in which to create the compute context. If not specified, the first target will be used instead. The target can exist either in the local project configuration or in the global .sasjsrc file.","title":"Syntax"},{"location":"context/#compute-context-structure","text":"The create and edit actions use the same JSON structure for adding / modifying contexts. This also matches the context made by the export action, which can be used to provide a template for adding / modifying new contexts. The JSON is defined as follows: { \"name\": \"myNewComputeContext\", \"attributes\": { \"reuseServerProcesses\": true, \"runServerAs\": \"mycasaccount\" }, \"environment\": { \"autoExecLines\": [ \"%put autoexec line 1;\", \"%put autoexect line 2;\" ], \"options\": [ \"-BUFNO 10\", \"-MEMSIZE 4G\" ] }, \"launchContext\": { \"contextName\": \"SAS Job Execution launcher context\" }, \"launchType\": \"service\", } To explain the sections: name - name of the compute context you will create reuseServerProcesses - since Viya 3.5 you can re-use sessions, this improves performance significantly but requires the sessions to run under a system account (defined below) runServerAs - the system account to use when re-using server processes autoExecLines - an array of SAS program lines. These will execute ONCE when the server process is started, so expensive libname assignments could be placed here, speeding up web service response times. options - an array of SAS option settings contextName - the name of the launcher context used to spawn the compute context launchtype - a mandatory parameter, more details here","title":"Compute Context Structure"},{"location":"context/#sasjs-context-create","text":"Used to create a new compute context.","title":"sasjs context create"},{"location":"context/#syntax_1","text":"sasjs context create -s source.json -t target","title":"Syntax"},{"location":"context/#usage","text":"# create minimal context config cat > ./myContext.json <<'EOL' { \"name\": \"myNewComputeContext\", \"launchContext\": { \"contextName\": \"SAS Job Execution launcher context\" }, \"launchType\": \"service\" } EOL # create the context using the target defined in sasjs add sasjs context create -s ./myContext.json -t myTarget","title":"Usage"},{"location":"context/#sasjs-context-delete","text":"Used to delete an existing context. No source JSON needed, contextName is used instead.","title":"sasjs context delete"},{"location":"context/#syntax_2","text":"sasjs context delete <contextName> -t target","title":"Syntax"},{"location":"context/#usage_1","text":"sasjs context delete myUndesirableComputeContext -t myTarget","title":"Usage"},{"location":"context/#sasjs-context-edit","text":"Used to edit an existing context","title":"sasjs context edit"},{"location":"context/#syntax_3","text":"sasjs context edit <contextName> -s source.json -t target","title":"Syntax"},{"location":"context/#usage_2","text":"# create JSON file with the changes to apply cat > ./myContext.json <<'EOL' { \"name\": \"myRenamedComputeContext\", \"launchContext\": { \"contextName\": \"Some Other launcher context\" }, \"launchType\": \"service\" } EOL # update the context named myComputeContext sasjs context edit myComputeContext -s ./myContext.json -t myTarget","title":"Usage"},{"location":"context/#sasjs-context-export","text":"Exports specified compute context to contextName.json in the current folder. No source JSON is needed, just provide the contextName .","title":"sasjs context export"},{"location":"context/#syntax_4","text":"sasjs context export <contextName> -t target","title":"Syntax"},{"location":"context/#usage_3","text":"sasjs context export someContext -t myTarget","title":"Usage"},{"location":"context/#sasjs-context-list","text":"Outputs a list of all accessible and inaccessible contexts. Accessible contexts are discovered by attempting to run %put &=sysuserid; on each context.","title":"sasjs context list"},{"location":"context/#syntax_5","text":"sasjs context list -t target","title":"Syntax"},{"location":"context/#usage_4","text":"sasjs context list -t myTarget","title":"Usage"},{"location":"create/","text":"sasjs create \u00b6 To create a new project, run: sasjs create mynewproject To install in an existing project, change into that directory and run: sasjs create (without arguments). This will create a sas folder inside the directory, and - if a package.json file exists - the @sasjs/core dependency will be added. An additional option can be specified to create a web app from a template, eg: sasjs create my-sas-project --template react . The --template alias can be shortened to -t (not to be confused with the -t target shortcut used in many other sasjs commands). The following templates are available: Angular - a quickstart for building angular projects React - a quickstart for React based projects minimal - a basic app using vanilla javascript sasonly - an app that only contains backend SAS (web) services jobs - an app that only contains backend SAS jobs (including a flow example)","title":"sasjs create"},{"location":"create/#sasjs-create","text":"To create a new project, run: sasjs create mynewproject To install in an existing project, change into that directory and run: sasjs create (without arguments). This will create a sas folder inside the directory, and - if a package.json file exists - the @sasjs/core dependency will be added. An additional option can be specified to create a web app from a template, eg: sasjs create my-sas-project --template react . The --template alias can be shortened to -t (not to be confused with the -t target shortcut used in many other sasjs commands). The following templates are available: Angular - a quickstart for building angular projects React - a quickstart for React based projects minimal - a basic app using vanilla javascript sasonly - an app that only contains backend SAS (web) services jobs - an app that only contains backend SAS jobs (including a flow example)","title":"sasjs create"},{"location":"deploy/","text":"sasjs deploy \u00b6 Deploy to multiple servers, server types (Viya, EBI, Base), multiple folders (Drive or Metadata) within those folders, and with multiple configurations, each with a simple alias - a target name . The ability to easily deploy (and subsequently execute) your SAS code enables you to develop locally using established GIT workflows. Prerequisites \u00b6 Before using this command, you will need to install the SASJS CLI and: add a deployment target . compile services . build services . Syntax \u00b6 The build program generated in the previous step can be deployed in 3 ways: 1 - MANUAL: copy paste the code into Studio or Enterprise Guide and run it 2 - SSH: build a shell script or bat file to load, and execute with a web service 3 - API: use the SAS APIs 2nd and 3rd options can be configured and executed with a single command: sasjs deploy --target(-t) <target name> or: sasjs d --target(-t) <target name> You can compile, build and deploy using: sasjs cbd --target(-t) <target name> If you don't specify a target (eg sas9 or viya ) then the default target in the sasjsconfig.json file is used. If local configuration file is not found, global .sasjsrc file will be used. NOTE: By default deploy will overwrite an existing deploy (force deploy). Copy/Paste approach \u00b6 The build script (named as per buildOutputFileName ) can be copy pasted into SAS Studio and executed to create the backend services. Please note: You will be running under your own identity. If you need files created under the Web Server identity, deploy your build script using a web service. For Viya, you must use SASStudioV (or ensure the client/secret/access_token are provided) SSH approach \u00b6 You can SSH (rsync or scp) your build script onto the SAS Server then %inc it from a web service - the web service could be created using the code below: filename mc url \"https://raw.githubusercontent.com/sasjs/core/main/all.sas\" ; %inc mc; filename ft15f001 temp; parmcards4; %inc \"/path/to/your/sasjsdeploy.sas\" /source2; ;;;; %mp_createwebservice (name=Executor, code=ft15f001 , replace =YES) This creates the service in your HOME directory (SAS 9 or Viya). You can now create a local script (eg mysas9deploy.sh ) and add it to the deployScripts array (the root is always the directory containing the sasjs folder). echo \"sasjs: uploading frontend\" rsync -avz /home/me/myapp/dist/* me@sasserver:/var/www/html/myapp echo \"sasjs: uploading deploy program\" scp sasjsbuild/mysas9deploy.sas me@sasserver:/tmp/mysas9deploy.sas echo \"sasjs: running Executor\" curl -v -L -k -b cookiefile -c cookiefile \" $URL & $CREDS \" API Approach \u00b6 Any files in your deployScripts array that have a \".sas\" extension will be sent to the relevant SAS Server for execution. Viya API deployment \u00b6 The Viya deploy requires 3 things: access_token serverUrl contextName In order of priority, the access_token is taken from the .env.targetname file, then the .env file (if not found). The serverUrl is the location of your Viya server. The contextName is the execution service on which your SAS code will execute. You can get a list of available contexts by running a GET to the following endpoint: /compute/contexts","title":"sasjs deploy"},{"location":"deploy/#sasjs-deploy","text":"Deploy to multiple servers, server types (Viya, EBI, Base), multiple folders (Drive or Metadata) within those folders, and with multiple configurations, each with a simple alias - a target name . The ability to easily deploy (and subsequently execute) your SAS code enables you to develop locally using established GIT workflows.","title":"sasjs deploy"},{"location":"deploy/#prerequisites","text":"Before using this command, you will need to install the SASJS CLI and: add a deployment target . compile services . build services .","title":"Prerequisites"},{"location":"deploy/#syntax","text":"The build program generated in the previous step can be deployed in 3 ways: 1 - MANUAL: copy paste the code into Studio or Enterprise Guide and run it 2 - SSH: build a shell script or bat file to load, and execute with a web service 3 - API: use the SAS APIs 2nd and 3rd options can be configured and executed with a single command: sasjs deploy --target(-t) <target name> or: sasjs d --target(-t) <target name> You can compile, build and deploy using: sasjs cbd --target(-t) <target name> If you don't specify a target (eg sas9 or viya ) then the default target in the sasjsconfig.json file is used. If local configuration file is not found, global .sasjsrc file will be used. NOTE: By default deploy will overwrite an existing deploy (force deploy).","title":"Syntax"},{"location":"deploy/#copypaste-approach","text":"The build script (named as per buildOutputFileName ) can be copy pasted into SAS Studio and executed to create the backend services. Please note: You will be running under your own identity. If you need files created under the Web Server identity, deploy your build script using a web service. For Viya, you must use SASStudioV (or ensure the client/secret/access_token are provided)","title":"Copy/Paste approach"},{"location":"deploy/#ssh-approach","text":"You can SSH (rsync or scp) your build script onto the SAS Server then %inc it from a web service - the web service could be created using the code below: filename mc url \"https://raw.githubusercontent.com/sasjs/core/main/all.sas\" ; %inc mc; filename ft15f001 temp; parmcards4; %inc \"/path/to/your/sasjsdeploy.sas\" /source2; ;;;; %mp_createwebservice (name=Executor, code=ft15f001 , replace =YES) This creates the service in your HOME directory (SAS 9 or Viya). You can now create a local script (eg mysas9deploy.sh ) and add it to the deployScripts array (the root is always the directory containing the sasjs folder). echo \"sasjs: uploading frontend\" rsync -avz /home/me/myapp/dist/* me@sasserver:/var/www/html/myapp echo \"sasjs: uploading deploy program\" scp sasjsbuild/mysas9deploy.sas me@sasserver:/tmp/mysas9deploy.sas echo \"sasjs: running Executor\" curl -v -L -k -b cookiefile -c cookiefile \" $URL & $CREDS \"","title":"SSH approach"},{"location":"deploy/#api-approach","text":"Any files in your deployScripts array that have a \".sas\" extension will be sent to the relevant SAS Server for execution.","title":"API Approach"},{"location":"deploy/#viya-api-deployment","text":"The Viya deploy requires 3 things: access_token serverUrl contextName In order of priority, the access_token is taken from the .env.targetname file, then the .env file (if not found). The serverUrl is the location of your Viya server. The contextName is the execution service on which your SAS code will execute. You can get a list of available contexts by running a GET to the following endpoint: /compute/contexts","title":"Viya API deployment"},{"location":"doc/","text":"sasjs doc \u00b6 The sasjs doc command enables developers to generate HTML documentation directly from the comment headers used in SAS Jobs, Services, Tests, Macros and Includes. An example of the generated documentation can be found here . The comment headers must follow the Doxygen standard. It is possible to embed images, tables, bullet points, GIFs, links, and even raw HTML. Data Lineage \u00b6 If the doxygen headers in any of the SAS Jobs or Services contain lists of data inputs and/or data outputs in the following format: <h4> Data Inputs </h4> @li libref.tablename1 @li libref.tablename2 <h4> Data Outputs </h4> @li libref.tablename3 Then a data lineage diagram will also be generated (linking data inputs to programs to data ouputs). In the diagram, programs will link to the documented program, and - if configured - the tables will link directly to the viewer in Data Controller . Given that the same headers used to generate the documentation are used to compile the Services and Jobs, the documentation will naturally stay up to date - so long as you are using sasjs compile to prepare them. Note Jobs and Services are defined in the jobConfig.jobFolders and serviceConfig.serviceFolders arrays respectively. Lineage is NOT generated for macros (macroFolders) or programs (programFolders). Prerequisites \u00b6 Before using this command, you will need to install the SASjs CLI and Doxygen . sasjs doc \u00b6 Generates HTML docs for all .sas files contained in the programFolders / macroFolders / jobFolders / serviceFolders listed in the sasjsconfig.json file, for all targets. If a specific target is provided, the generated docs will ignore content from the other targets. sasjs docs is an alias for sasjs doc . Syntax \u00b6 sasjs doc -t <targetName> --outDirectory <sasFilePath> sasFilePath - if this has a leading slash (eg /my-docs) then it must be the full path. If it is a relative path (without a leading slash, eg my-docs) then it will be pre-pended with the project root folder. Additional arguments may include: --target (alias -t ) - If a target is provided, the generated docs will ignore content from the other targets. The target can exist either in the local project configuration or in the global .sasjsrc file. Examples \u00b6 # generates docs in default folder i.e. ./sasjsbuild/docs, using all targets as a source sasjs doc # generates docs in default folder i.e. ./sasjsbuild/docs, using a specific target sasjs doc -t viya # generates docs in specific folder i.e. ./my-docs, using a particular target sasjs doc -t viya --outDirectory my-docs sasjs doc init \u00b6 For existing SASjs projects (eg those created prior to the implementation of the sasjs doc command, or where the doxy folder is otherwise uninitialised) OR to reset doxygen configuration/content, it is possible to initialise the config files using the sasjs doc init command. This will create the 'doxy' folder under 'sasjs', and make it ready to use sasjs doc For new projects using sasjs create , sasjs doc init is not required - the doxy folder and requisite files are created automatically. Syntax \u00b6 sasjs doc init Tips and Tricks \u00b6 By default, the project title and description are taken from the package.json file in the root of the project. You can modify this behaviour (and many other doxygen defaults) by editing the sasjs/doxy/doxyFile file. The docConfig options are also documented here","title":"sasjs doc"},{"location":"doc/#sasjs-doc","text":"The sasjs doc command enables developers to generate HTML documentation directly from the comment headers used in SAS Jobs, Services, Tests, Macros and Includes. An example of the generated documentation can be found here . The comment headers must follow the Doxygen standard. It is possible to embed images, tables, bullet points, GIFs, links, and even raw HTML.","title":"sasjs doc"},{"location":"doc/#data-lineage","text":"If the doxygen headers in any of the SAS Jobs or Services contain lists of data inputs and/or data outputs in the following format: <h4> Data Inputs </h4> @li libref.tablename1 @li libref.tablename2 <h4> Data Outputs </h4> @li libref.tablename3 Then a data lineage diagram will also be generated (linking data inputs to programs to data ouputs). In the diagram, programs will link to the documented program, and - if configured - the tables will link directly to the viewer in Data Controller . Given that the same headers used to generate the documentation are used to compile the Services and Jobs, the documentation will naturally stay up to date - so long as you are using sasjs compile to prepare them. Note Jobs and Services are defined in the jobConfig.jobFolders and serviceConfig.serviceFolders arrays respectively. Lineage is NOT generated for macros (macroFolders) or programs (programFolders).","title":"Data Lineage"},{"location":"doc/#prerequisites","text":"Before using this command, you will need to install the SASjs CLI and Doxygen .","title":"Prerequisites"},{"location":"doc/#sasjs-doc_1","text":"Generates HTML docs for all .sas files contained in the programFolders / macroFolders / jobFolders / serviceFolders listed in the sasjsconfig.json file, for all targets. If a specific target is provided, the generated docs will ignore content from the other targets. sasjs docs is an alias for sasjs doc .","title":"sasjs doc"},{"location":"doc/#syntax","text":"sasjs doc -t <targetName> --outDirectory <sasFilePath> sasFilePath - if this has a leading slash (eg /my-docs) then it must be the full path. If it is a relative path (without a leading slash, eg my-docs) then it will be pre-pended with the project root folder. Additional arguments may include: --target (alias -t ) - If a target is provided, the generated docs will ignore content from the other targets. The target can exist either in the local project configuration or in the global .sasjsrc file.","title":"Syntax"},{"location":"doc/#examples","text":"# generates docs in default folder i.e. ./sasjsbuild/docs, using all targets as a source sasjs doc # generates docs in default folder i.e. ./sasjsbuild/docs, using a specific target sasjs doc -t viya # generates docs in specific folder i.e. ./my-docs, using a particular target sasjs doc -t viya --outDirectory my-docs","title":"Examples"},{"location":"doc/#sasjs-doc-init","text":"For existing SASjs projects (eg those created prior to the implementation of the sasjs doc command, or where the doxy folder is otherwise uninitialised) OR to reset doxygen configuration/content, it is possible to initialise the config files using the sasjs doc init command. This will create the 'doxy' folder under 'sasjs', and make it ready to use sasjs doc For new projects using sasjs create , sasjs doc init is not required - the doxy folder and requisite files are created automatically.","title":"sasjs doc init"},{"location":"doc/#syntax_1","text":"sasjs doc init","title":"Syntax"},{"location":"doc/#tips-and-tricks","text":"By default, the project title and description are taken from the package.json file in the root of the project. You can modify this behaviour (and many other doxygen defaults) by editing the sasjs/doxy/doxyFile file. The docConfig options are also documented here","title":"Tips and Tricks"},{"location":"env/","text":"env file \u00b6 When running the CLI a number of environment variables are required - for authentication, debugging etc. These variables can be actual environment variables (set as part of the shell invocation) or, loaded on startup from a .env file in the root of the SASjs project. As different targets often have different variables (eg connection strings) a .env may be \"scoped\" with the target name, eg .env.TARGETNAME . If a .env.TARGETNAME file is not found, then the generic .env file is used. The following options may be defined, depending on your use case: ACCESS_TOKEN \u00b6 Typically created when running sasjs auth . Used for authentication to the Viya and SASjs APIs. REFRESH_TOKEN \u00b6 Created when running sasjs auth against a Viya target. The CLI will use this to auto-refresh the access token if needed. VERBOSE \u00b6 Verbose mode will log a summary of every HTTP request/response to the console - this is helpful in troubleshooting edge cases and unusual server responses. VERBOSE=ON (case insensitive) will enable the debug mode. To remove extra colors from logged message, set VERBOSE=BLEACHED (case insensitive). Everything else (eg VERBOSE=OFF ) will disable it. The option is disabled by default. Verbose mode will also be enabled if LOG_LEVEL is set to Trace (case insensitive) in the .env* file. Note Verbose mode can also be enabled for a single sasjs job execute command by adding the --verbose ( -v ) flag. To enable bleached verbose mode, add bleached after -v flag (eg sasjs job execute -v bleached ).","title":"ENV File"},{"location":"env/#env-file","text":"When running the CLI a number of environment variables are required - for authentication, debugging etc. These variables can be actual environment variables (set as part of the shell invocation) or, loaded on startup from a .env file in the root of the SASjs project. As different targets often have different variables (eg connection strings) a .env may be \"scoped\" with the target name, eg .env.TARGETNAME . If a .env.TARGETNAME file is not found, then the generic .env file is used. The following options may be defined, depending on your use case:","title":"env file"},{"location":"env/#access_token","text":"Typically created when running sasjs auth . Used for authentication to the Viya and SASjs APIs.","title":"ACCESS_TOKEN"},{"location":"env/#refresh_token","text":"Created when running sasjs auth against a Viya target. The CLI will use this to auto-refresh the access token if needed.","title":"REFRESH_TOKEN"},{"location":"env/#verbose","text":"Verbose mode will log a summary of every HTTP request/response to the console - this is helpful in troubleshooting edge cases and unusual server responses. VERBOSE=ON (case insensitive) will enable the debug mode. To remove extra colors from logged message, set VERBOSE=BLEACHED (case insensitive). Everything else (eg VERBOSE=OFF ) will disable it. The option is disabled by default. Verbose mode will also be enabled if LOG_LEVEL is set to Trace (case insensitive) in the .env* file. Note Verbose mode can also be enabled for a single sasjs job execute command by adding the --verbose ( -v ) flag. To enable bleached verbose mode, add bleached after -v flag (eg sasjs job execute -v bleached ).","title":"VERBOSE"},{"location":"faq/","text":"FAQ \u00b6 What is the difference between local and global targets? \u00b6 A target is a set of attributes (eg serverUrl , serverType , appLoc ) to which a project will be deployed, or some code executed. When running locally , inside a project (eg a GIT repository) these attributes are taken from the sasjs/sasjsconfig.json file. By contrast, any (sensitive) authorisation attributes are retrieved from the .env.$(targetname) file, which is typically .gitignore 'd for security. When running outside of a project, the attributes are taken from the global ~/.sasjsrc file in the user home directory. In this case, authorisation details are also stored in the same file (authConfig). The sasjs command will \"discover\" if it is inside a local project by the presence of a sasjs/sasjsconfig.json file in the current, or any of the parent directories. If not found, then the ~/.sasjsrc file will be searched instead. It's worth noting that there are typically MORE attributes defind in a local target, because this is where an application is normally configured in detail for deployment. The global target is more for general use, such as running arbitrary jobs or SAS code. A diagram of the rules for determining whether a local or remote target is used is available below. How can I obtain a Viya client and secret? \u00b6 For setting up the client / secret you will need the services of an administrator (a user with admin rights on the physical machine) as they need to query a protected file (the consul token). The client must be created with the 'authorization_code' grant type. If you are building a standalone application, it is also recommended to increase the expiry period of the refresh token to avoid manual re-authentications. The default expiry is 24 hours for an access token, and 30 days for a refresh token. This can be extended up to around 60 or 70 years. Viya 2025 \u00b6 The latest instructions are available here . Our recommended approach is to use the browser as follows: Open the following url as an administrator: https://<sas-server>/SASLogon/oauth/authorize?client_id=sas.cli&response_type=token This will redirect to a new url. Extract the access_token parameter and use it in the query below: curl -k -X POST \"https://viya-f0g8ht62vq.engage.sas.com/SASLogon/oauth/clients\" \\ -H \"Content-Type: application/json\" \\ -H \"Authorization: Bearer VERY_LONG_ACCESS_TOKEN_FROM_STEP_ABOVE\" \\ -d '{\"client_id\": \"YOUR_CLIENT\",\"client_secret\": \"YOUR_SECRET\",` \\ `\"scope\": [\"openid\"],\"autoapprove\":true,` \\ `\"authorized_grant_types\": [\"authorization_code\",\"refresh_token\"],` \\ ` \"redirect_uri\": \"urn:ietf:wg:oauth:2.0:oob\"}' This will create a YOUR_CLIENT and YOUR_SECRET client/secret pair using the authorization_code grant type (suitable for SASjs). Legacy Tools \u00b6 SASjs provides two legacy tools for older versions of Viya: Viya Token Web App This is a web app for configuring a client & secret in multiple ways. Only valid for Viya 3.5 To deploy, see here: https://sasjs.io/apps/#viya-client-token-generator Viya Token Macros You can also generate a client / secret (and access / refresh token) using SAS code, on both Viya 3.5 and Viya 4, using the mv_registerclient macro. /* compile the macros from github */ filename mc url \"https://raw.githubusercontent.com/sasjs/core/main/all.sas\" ; %inc mc; /* create random client and secret on Viya 3.5 (admin rights needed) */ %mv_registerclient (outds=clientinfo) /* create random client and secret on Viya 4 (consul token needed) */ %mv_registerclient (consul_token=12x34sa43v2345n234lasd) This will generate a URL in the log, which must be followed to generate a refresh code (one time step). Paste that code into the macro below to generate an access / refresh token: /* paste the code below */ %mv_tokenauth(inds=clientinfo,code=xET8ETs74z) /* extract client, secret & token to the log */ data _null_; merge mv_tokenauth clientinfo(drop=error); put access_token=; put refresh_token=; put client_id=; put client_secret=; run; How Does Authentication / Token Management work with SAS Viya? \u00b6 The CLI will only work with client / secret pairs that have the 'authorization_code' grant type. It does not support the username / password (Basic Authentication) approach, for security reasons. Once you provide the client (and secret) to SASjs, either as part of sasjs add or sasjs auth then a URL is presented to which the user must authenticate the CLIENT_ID. Once the user provides the authorisation code, the CLI uses the client / secret / auth code to obtain an ACCESS_TOKEN and REFRESH_TOKEN. The ACCESS_TOKEN may then be used for API requests until it expires. On expriy, or getting very close to it, the CLI will use the REFRESH_TOKEN to obtain a fresh ACCESS_TOKEN. Once the REFRESH_TOKEN expires, the CLIENT must be re-authenticated using SAS Logon. More information on token expiry is available here . The below diagram illustrates this flow, but not precisely - the diagram describes the flow for a deployed application, where the secret can be secured at backend. In the SASjs CLI case the entire app is frontend (nothing to deploy at backend), and so the SECRET must also be kept on the frontend. Why does SASjs take so long to install? \u00b6 Actually it doesn't, it should be fast. If you're waiting a long time (eg, over a minute) then the following may be the root cause: Virus Scanner checking every file that is downloaded Proxy settings (in which case, update the PAC file) Slow network connection The PAC file issue will only apply in corporate settings. The steps to address: Look in PAC for your proxy settings Set them in npm npm config set proxy <<address>> - npm config set https-proxy <<address>>","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what-is-the-difference-between-local-and-global-targets","text":"A target is a set of attributes (eg serverUrl , serverType , appLoc ) to which a project will be deployed, or some code executed. When running locally , inside a project (eg a GIT repository) these attributes are taken from the sasjs/sasjsconfig.json file. By contrast, any (sensitive) authorisation attributes are retrieved from the .env.$(targetname) file, which is typically .gitignore 'd for security. When running outside of a project, the attributes are taken from the global ~/.sasjsrc file in the user home directory. In this case, authorisation details are also stored in the same file (authConfig). The sasjs command will \"discover\" if it is inside a local project by the presence of a sasjs/sasjsconfig.json file in the current, or any of the parent directories. If not found, then the ~/.sasjsrc file will be searched instead. It's worth noting that there are typically MORE attributes defind in a local target, because this is where an application is normally configured in detail for deployment. The global target is more for general use, such as running arbitrary jobs or SAS code. A diagram of the rules for determining whether a local or remote target is used is available below.","title":"What is the difference between local and global targets?"},{"location":"faq/#how-can-i-obtain-a-viya-client-and-secret","text":"For setting up the client / secret you will need the services of an administrator (a user with admin rights on the physical machine) as they need to query a protected file (the consul token). The client must be created with the 'authorization_code' grant type. If you are building a standalone application, it is also recommended to increase the expiry period of the refresh token to avoid manual re-authentications. The default expiry is 24 hours for an access token, and 30 days for a refresh token. This can be extended up to around 60 or 70 years.","title":"How can I obtain a Viya client and secret?"},{"location":"faq/#viya-2025","text":"The latest instructions are available here . Our recommended approach is to use the browser as follows: Open the following url as an administrator: https://<sas-server>/SASLogon/oauth/authorize?client_id=sas.cli&response_type=token This will redirect to a new url. Extract the access_token parameter and use it in the query below: curl -k -X POST \"https://viya-f0g8ht62vq.engage.sas.com/SASLogon/oauth/clients\" \\ -H \"Content-Type: application/json\" \\ -H \"Authorization: Bearer VERY_LONG_ACCESS_TOKEN_FROM_STEP_ABOVE\" \\ -d '{\"client_id\": \"YOUR_CLIENT\",\"client_secret\": \"YOUR_SECRET\",` \\ `\"scope\": [\"openid\"],\"autoapprove\":true,` \\ `\"authorized_grant_types\": [\"authorization_code\",\"refresh_token\"],` \\ ` \"redirect_uri\": \"urn:ietf:wg:oauth:2.0:oob\"}' This will create a YOUR_CLIENT and YOUR_SECRET client/secret pair using the authorization_code grant type (suitable for SASjs).","title":"Viya 2025"},{"location":"faq/#legacy-tools","text":"SASjs provides two legacy tools for older versions of Viya: Viya Token Web App This is a web app for configuring a client & secret in multiple ways. Only valid for Viya 3.5 To deploy, see here: https://sasjs.io/apps/#viya-client-token-generator Viya Token Macros You can also generate a client / secret (and access / refresh token) using SAS code, on both Viya 3.5 and Viya 4, using the mv_registerclient macro. /* compile the macros from github */ filename mc url \"https://raw.githubusercontent.com/sasjs/core/main/all.sas\" ; %inc mc; /* create random client and secret on Viya 3.5 (admin rights needed) */ %mv_registerclient (outds=clientinfo) /* create random client and secret on Viya 4 (consul token needed) */ %mv_registerclient (consul_token=12x34sa43v2345n234lasd) This will generate a URL in the log, which must be followed to generate a refresh code (one time step). Paste that code into the macro below to generate an access / refresh token: /* paste the code below */ %mv_tokenauth(inds=clientinfo,code=xET8ETs74z) /* extract client, secret & token to the log */ data _null_; merge mv_tokenauth clientinfo(drop=error); put access_token=; put refresh_token=; put client_id=; put client_secret=; run;","title":"Legacy Tools"},{"location":"faq/#how-does-authentication-token-management-work-with-sas-viya","text":"The CLI will only work with client / secret pairs that have the 'authorization_code' grant type. It does not support the username / password (Basic Authentication) approach, for security reasons. Once you provide the client (and secret) to SASjs, either as part of sasjs add or sasjs auth then a URL is presented to which the user must authenticate the CLIENT_ID. Once the user provides the authorisation code, the CLI uses the client / secret / auth code to obtain an ACCESS_TOKEN and REFRESH_TOKEN. The ACCESS_TOKEN may then be used for API requests until it expires. On expriy, or getting very close to it, the CLI will use the REFRESH_TOKEN to obtain a fresh ACCESS_TOKEN. Once the REFRESH_TOKEN expires, the CLIENT must be re-authenticated using SAS Logon. More information on token expiry is available here . The below diagram illustrates this flow, but not precisely - the diagram describes the flow for a deployed application, where the secret can be secured at backend. In the SASjs CLI case the entire app is frontend (nothing to deploy at backend), and so the SECRET must also be kept on the frontend.","title":"How Does Authentication / Token Management work with SAS Viya?"},{"location":"faq/#why-does-sasjs-take-so-long-to-install","text":"Actually it doesn't, it should be fast. If you're waiting a long time (eg, over a minute) then the following may be the root cause: Virus Scanner checking every file that is downloaded Proxy settings (in which case, update the PAC file) Slow network connection The PAC file issue will only apply in corporate settings. The steps to address: Look in PAC for your proxy settings Set them in npm npm config set proxy <<address>> - npm config set https-proxy <<address>>","title":"Why does SASjs take so long to install?"},{"location":"flow/","text":"sasjs flow \u00b6 The sasjs flow command allows SAS Administrators to configure a batch schedule using a JSON file, to trigger the batch using a command line, and to capture the results of the flow in a CSV file. Jobs can be executed in parallel, or in sequence following the successful completion of the previous job(s). Prerequisites \u00b6 Before using this command, you will need to: install the SASjs CLI add a deployment target. Create a flow source (JSON) file. Syntax \u00b6 sasjs flow <action> [additional arguments] Additional arguments may include: --source (alias -s ) - path to the flow definition source file (*.json). --logFolder (alias -l ) - path to the folder where job logs will be saved. --csvFile (alias -c ) - path to the CSV file containing job statuses will be saved. This file is replaced if the command is re-executed. --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. Source JSON file \u00b6 This is the file where the pattern of the flow is configured. A very simple flow definition might look like this: { \"name\": \"simpleFlow\", \"flows\": { \"flow01\": { \"jobs\": [ { \"location\": \"/Projects/subfolder/someJob1\" },{ \"location\": \"/Projects/subfolder/someJob2\" } ], \"predecessors\": [] } } } The above is named \"simpleFlow\" with one flow named \"flow01\" and two Viya Jobs - which will execute in parallel (as they are in the same flow). A more complicated one would look like this: { \"name\": \"myAmazingFlow\", \"flows\": { \"ourveryfirstflow\": { \"jobs\": [ { \"location\": \"/Projects/job1\" }, { \"location\": \"/Projects/job2\" }, { \"location\": \"/Projects/job3\" } ], \"predecessors\": [] }, \"secondflow\": { \"jobs\": [ { \"location\": \"/Projects/job11\" } ], \"predecessors\": [ \"firstflow\" ] }, \"anotherflow\": { \"jobs\": [ { \"location\": \"/Public/job15\" } ], \"predecessors\": [ \"ourveryfirstflow\", \"secondflow\" ] } }, \"yetanotherflow\": { \"jobs\": [ { \"location\": \"/Public/job115\" } ], \"predecessors\": [] } } } The above contains a flow definition with 4 flows: \"ourveryfirstflow\" - triggers 3 jobs at once, runs immediately as no predecessors \"yetanotherflow\" - triggers 1 job, runs immediately as no predecesors \"secondflow\" - triggers as soon as firstflow is complete and ONLY if the jobs all finish with SUCCESS status \"anotherflow\" - triggers once firstflow and secondflow are complete, but ONLY if all finish with SUCCESS sasjs flow execute \u00b6 Used to trigger the execution a flow of jobs on the SAS server. Syntax \u00b6 sasjs flow execute --source /local/flow.json --logFolder /local/log/folder --csvFile /local/some.csv -t targetName The following arguments are optional: logFolder - will default to the sasjsresults folder csvFile - will also default to the sasjsresults folder t - will default to the defaultTarget attribute (if available) Usage \u00b6 # run the flow of jobs using the target defined in sasjs add sasjs flow execute -s /local/flow.json -l /local/log/folder --csvFile /local/some.csv -t myTarget This will schedule SAS jobs and execute them according to the flow definition in the JSON file. Job logs will be returned as \".log' text files and saved to the local ( --logFolder ) folder. Details of the Job Executions and their status will be saved to the CSV file. See Also \u00b6 sasjs job execute","title":"sasjs flow"},{"location":"flow/#sasjs-flow","text":"The sasjs flow command allows SAS Administrators to configure a batch schedule using a JSON file, to trigger the batch using a command line, and to capture the results of the flow in a CSV file. Jobs can be executed in parallel, or in sequence following the successful completion of the previous job(s).","title":"sasjs flow"},{"location":"flow/#prerequisites","text":"Before using this command, you will need to: install the SASjs CLI add a deployment target. Create a flow source (JSON) file.","title":"Prerequisites"},{"location":"flow/#syntax","text":"sasjs flow <action> [additional arguments] Additional arguments may include: --source (alias -s ) - path to the flow definition source file (*.json). --logFolder (alias -l ) - path to the folder where job logs will be saved. --csvFile (alias -c ) - path to the CSV file containing job statuses will be saved. This file is replaced if the command is re-executed. --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file.","title":"Syntax"},{"location":"flow/#source-json-file","text":"This is the file where the pattern of the flow is configured. A very simple flow definition might look like this: { \"name\": \"simpleFlow\", \"flows\": { \"flow01\": { \"jobs\": [ { \"location\": \"/Projects/subfolder/someJob1\" },{ \"location\": \"/Projects/subfolder/someJob2\" } ], \"predecessors\": [] } } } The above is named \"simpleFlow\" with one flow named \"flow01\" and two Viya Jobs - which will execute in parallel (as they are in the same flow). A more complicated one would look like this: { \"name\": \"myAmazingFlow\", \"flows\": { \"ourveryfirstflow\": { \"jobs\": [ { \"location\": \"/Projects/job1\" }, { \"location\": \"/Projects/job2\" }, { \"location\": \"/Projects/job3\" } ], \"predecessors\": [] }, \"secondflow\": { \"jobs\": [ { \"location\": \"/Projects/job11\" } ], \"predecessors\": [ \"firstflow\" ] }, \"anotherflow\": { \"jobs\": [ { \"location\": \"/Public/job15\" } ], \"predecessors\": [ \"ourveryfirstflow\", \"secondflow\" ] } }, \"yetanotherflow\": { \"jobs\": [ { \"location\": \"/Public/job115\" } ], \"predecessors\": [] } } } The above contains a flow definition with 4 flows: \"ourveryfirstflow\" - triggers 3 jobs at once, runs immediately as no predecessors \"yetanotherflow\" - triggers 1 job, runs immediately as no predecesors \"secondflow\" - triggers as soon as firstflow is complete and ONLY if the jobs all finish with SUCCESS status \"anotherflow\" - triggers once firstflow and secondflow are complete, but ONLY if all finish with SUCCESS","title":"Source JSON file"},{"location":"flow/#sasjs-flow-execute","text":"Used to trigger the execution a flow of jobs on the SAS server.","title":"sasjs flow execute"},{"location":"flow/#syntax_1","text":"sasjs flow execute --source /local/flow.json --logFolder /local/log/folder --csvFile /local/some.csv -t targetName The following arguments are optional: logFolder - will default to the sasjsresults folder csvFile - will also default to the sasjsresults folder t - will default to the defaultTarget attribute (if available)","title":"Syntax"},{"location":"flow/#usage","text":"# run the flow of jobs using the target defined in sasjs add sasjs flow execute -s /local/flow.json -l /local/log/folder --csvFile /local/some.csv -t myTarget This will schedule SAS jobs and execute them according to the flow definition in the JSON file. Job logs will be returned as \".log' text files and saved to the local ( --logFolder ) folder. Details of the Job Executions and their status will be saved to the CSV file.","title":"Usage"},{"location":"flow/#see-also","text":"sasjs job execute","title":"See Also"},{"location":"folder/","text":"sasjs folder \u00b6 The sasjs folder command allows users to manage logical SAS Viya Folders (the kind that appear in SAS Drive). These are not to be confused with physical (filesystem) directories. The Viya Folder tree is actually stored in a Postgres Database. It is useful to be able to create and delete folders as part of CI/CD, for instance when tearing down part of an environment in order to rebuild it. Prerequisites \u00b6 Before using this command, you will need to install the SASJS CLI and add a deployment target . Syntax \u00b6 sasjs folder <action> [additional arguments] Additional arguments include: --target (alias -t ) - the target environment in which to create the SAS Folder. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. sasjs folder list \u00b6 Used to list first level children folders of given folder. Syntax \u00b6 sasjs folder list <folderpath> -t target Usage \u00b6 sasjs folder list /Public -t myTarget sasjs folder create \u00b6 Used to create a new SAS folder. Will fail if the folder already exists. If the -f flag is used, a new folder will be forcibly created (ie, if there is an existing one, it will be deleted). Syntax \u00b6 sasjs folder create <folderpath> -t target -f Usage \u00b6 sasjs folder create /Public/new/folder -t myTarget sasjs folder delete \u00b6 Used to delete an existing SAS Folder. To avoid the overhead with recursively deleting folders and content, the delete command actually moves the requisite folder into the Recycle Bin. This makes it very fast, as well as reversable. Syntax \u00b6 sasjs folder delete <folderpath> -t target Usage \u00b6 sasjs folder delete /Public/new/folder -t myTarget sasjs folder move \u00b6 Moves an existing folder to a new location. It behaves similarly to the Unix mv command. If targetpath is an existing folder, the folder will be moved underneath targetpath . If targetpath does not exist, the folder is moved and renamed, inside the parent folder. See examples below. Syntax \u00b6 sasjs folder move <folderpath> <targetpath> Usage \u00b6 Moving folder to /Public sasjs folder move /Public/old/folder /Public -t myTarget Moving folder to folder2 leaving it in same directory sasjs folder move /Public/old/folder /Public/old/folder2 -t myTarget Moving folder to /Public and renaming to folder2 Reason for rename - /Public/folder2 does not exist. sasjs folder move /Public/old/folder /Public/folder2 -t myTarget","title":"sasjs folder"},{"location":"folder/#sasjs-folder","text":"The sasjs folder command allows users to manage logical SAS Viya Folders (the kind that appear in SAS Drive). These are not to be confused with physical (filesystem) directories. The Viya Folder tree is actually stored in a Postgres Database. It is useful to be able to create and delete folders as part of CI/CD, for instance when tearing down part of an environment in order to rebuild it.","title":"sasjs folder"},{"location":"folder/#prerequisites","text":"Before using this command, you will need to install the SASJS CLI and add a deployment target .","title":"Prerequisites"},{"location":"folder/#syntax","text":"sasjs folder <action> [additional arguments] Additional arguments include: --target (alias -t ) - the target environment in which to create the SAS Folder. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file.","title":"Syntax"},{"location":"folder/#sasjs-folder-list","text":"Used to list first level children folders of given folder.","title":"sasjs folder list"},{"location":"folder/#syntax_1","text":"sasjs folder list <folderpath> -t target","title":"Syntax"},{"location":"folder/#usage","text":"sasjs folder list /Public -t myTarget","title":"Usage"},{"location":"folder/#sasjs-folder-create","text":"Used to create a new SAS folder. Will fail if the folder already exists. If the -f flag is used, a new folder will be forcibly created (ie, if there is an existing one, it will be deleted).","title":"sasjs folder create"},{"location":"folder/#syntax_2","text":"sasjs folder create <folderpath> -t target -f","title":"Syntax"},{"location":"folder/#usage_1","text":"sasjs folder create /Public/new/folder -t myTarget","title":"Usage"},{"location":"folder/#sasjs-folder-delete","text":"Used to delete an existing SAS Folder. To avoid the overhead with recursively deleting folders and content, the delete command actually moves the requisite folder into the Recycle Bin. This makes it very fast, as well as reversable.","title":"sasjs folder delete"},{"location":"folder/#syntax_3","text":"sasjs folder delete <folderpath> -t target","title":"Syntax"},{"location":"folder/#usage_2","text":"sasjs folder delete /Public/new/folder -t myTarget","title":"Usage"},{"location":"folder/#sasjs-folder-move","text":"Moves an existing folder to a new location. It behaves similarly to the Unix mv command. If targetpath is an existing folder, the folder will be moved underneath targetpath . If targetpath does not exist, the folder is moved and renamed, inside the parent folder. See examples below.","title":"sasjs folder move"},{"location":"folder/#syntax_4","text":"sasjs folder move <folderpath> <targetpath>","title":"Syntax"},{"location":"folder/#usage_3","text":"Moving folder to /Public sasjs folder move /Public/old/folder /Public -t myTarget Moving folder to folder2 leaving it in same directory sasjs folder move /Public/old/folder /Public/old/folder2 -t myTarget Moving folder to /Public and renaming to folder2 Reason for rename - /Public/folder2 does not exist. sasjs folder move /Public/old/folder /Public/folder2 -t myTarget","title":"Usage"},{"location":"fs/","text":"sasjs fs \u00b6 The sasjs fs command allows users to manage a remote SAS (physical) filesystem from a local machine. No SSH or FTP accounts are necessary - the tool makes use of the APIs (Viya, SASjs Server ) or a SAS EBI STP runner . Not to be confused with: the logical SAS Folders (eg SAS Drive or Metadata BIP Tree), managed using the sasjs folder command . the regular sasjs compile command, which creates self-contained Jobs / Services / Tests that do not require a filesystem . It is also possible to use this feature natively within the SASjs VSCode Extension - https://github.com/sasjs/vscode-extension#directory-synchronisation . Prerequisites \u00b6 Before using this command, you will need to: install the SASjs CLI add a deployment target (for all operations except sasjs fs compile ) Syntax \u00b6 sasjs fs <action> [additional arguments] Additional arguments may include: --target (alias -t ) - the target SAS Environment which contains the filesystem. Required attributes are serverUrl and serverType . If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. sasjs fs compile \u00b6 Used to generate a single SAS program that contains all the files (and subdirectories) of a given LOCAL folder. This program can be executed in any flavour of SAS to generate the files on the SAS server - simply set %let fsTarget=/your/target/folder; and run the program. To preserve encoding and special characters, as well as to enable the compilation of binary content, all files are base64 encoded. Syntax \u00b6 sasjs fs compile <localFolder> -o <programPath> Usage \u00b6 sasjs fs compile C:\\my\\project -o C:\\temp\\deployme.sas An extract from such a compiled program is shown below: %mf_mkdir(&fsTarget) filename _in64 temp lrecl=99999999; data _null_; file _in64; put 'ewogICIkc2NoZW1hIjogImh0dHBzOi8vY2xpLnNhc2pzLmlvL3Nhc2pzY29uZmlnLXNjaGVtYS5qc29uIiwKICAiZG9jQ29uZmlnIjogewogICAgImVuYWJsZUxpbmVhZ2UiOiB0cnVlLAogICAgImRveHlDb250ZW50IjogewogICAgICAicmVhZE1lIjogIi4uLy4uL1JFQURNRS5tZCIKICAg'@; put 'IH0sCiAgICAib3V0RGlyZWN0b3J5IjogInB1YmxpYy9kb2NzL3N0YXRpYy9zYXMiCiAgfSwKICAibWFjcm9Gb2xkZXJzIjogWyJzYXNqcy9tYWNyb3MiXSwKICAicHJvZ3JhbUZvbGRlcnMiOiBbXSwKICAic2VydmljZUNvbmZpZyI6IHsKICAgICJzZXJ2aWNlRm9sZGVycyI6IFsic2FzanMv'@; put 'c2VydmljZXMvY29tbW9uIiwgInNhc2pzL3NlcnZpY2VzL2ZpbGVzIl0sCiAgICAiaW5pdFByb2dyYW0iOiAic2FzanMvc2VydmljZXMvc2VydmljZWluaXQuc2FzIgogIH0sCiAgInN0cmVhbUNvbmZpZyI6IHsKICAgICJzdHJlYW1XZWIiOiB0cnVlLAogICAgInN0cmVhbVdlYkZvbGRlciI6'@; put 'ICJ3ZWJ2IiwKICAgICJ3ZWJTb3VyY2VQYXRoIjogImJ1aWxkIgogIH0sCiAgImRlZmF1bHRUYXJnZXQiOiAidml5YSIsCiAgInRhcmdldHMiOiBbCiAgICB7CiAgICAgICJuYW1lIjogInZpeWEiLAogICAgICAic2VydmVyVXJsIjogImh0dHBzOi8vYXp1cmV1c2UwMTEwNTkubXktdHJpYWxz'@; put 'LnNhcy5jb20vIiwKICAgICAgInNlcnZlclR5cGUiOiAiU0FTVklZQSIsCiAgICAgICJhcHBMb2MiOiAiL1B1YmxpYy9hcHAvcmVhY3Qtc2VlZC1hcHAiLAogICAgICAiY29udGV4dE5hbWUiOiAiU0FTIEpvYiBFeGVjdXRpb24gY29tcHV0ZSBjb250ZXh0IgogICAgfSwKICAgIHsKICAgICAg'@; put 'Im5hbWUiOiAic2VydmVyIiwKICAgICAgInNlcnZlclVybCI6ICJodHRwOi8vbG9jYWxob3N0OjUwMDAiLAogICAgICAic2VydmVyVHlwZSI6ICJTQVNKUyIsCiAgICAgICJodHRwc0FnZW50T3B0aW9ucyI6IHsKICAgICAgICAiYWxsb3dJbnNlY3VyZVJlcXVlc3RzIjogZmFsc2UKICAgICAg'@; put 'fSwKICAgICAgImFwcExvYyI6ICIvUHVibGljL2FwcC9yZWFjdC1zZWVkLWFwcCIsCiAgICAgICJkZXBsb3lDb25maWciOiB7CiAgICAgICAgImRlcGxveVNlcnZpY2VQYWNrIjogdHJ1ZSwKICAgICAgICAiZGVwbG95U2NyaXB0cyI6IFtdCiAgICAgIH0sCiAgICAgICJzdHJlYW1Db25maWci'@; put 'OiB7CiAgICAgICAgInN0cmVhbUxvZ28iOiAibG9nbzUxMi5wbmciLAogICAgICAgICJzdHJlYW1TZXJ2aWNlTmFtZSI6ICJSZWFjdCIsCiAgICAgICAgInN0cmVhbVdlYiI6IHRydWUsCiAgICAgICAgInN0cmVhbVdlYkZvbGRlciI6ICJ3ZWIiLAogICAgICAgICJ3ZWJTb3VyY2VQYXRoIjog'@; put 'ImJ1aWxkIiwKICAgICAgICAiYXNzZXRQYXRocyI6IFtdCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJuYW1lIjogInNhczkiLAogICAgICAic2VydmVyVHlwZSI6ICJTQVM5IiwKICAgICAgImFwcExvYyI6ICIvU2hhcmVkIERhdGEvc2FzanMvcmVhY3Qtc2VlZC1hcHAiLAogICAgICAi'@; put 'ZGVwbG95Q29uZmlnIjogewogICAgICAgICJkZXBsb3lTZXJ2aWNlUGFjayI6IHRydWUKICAgICAgfSwKICAgICAgInNlcnZlck5hbWUiOiAiU0FTQXBwIiwKICAgICAgInJlcG9zaXRvcnlOYW1lIjogIkZvdW5kYXRpb24iCiAgICB9CiAgXQp9Cg=='; run; filename _out64 \"&fsTarget/sasjsconfig.json\"; /* convert from base64 */ data _null_; length filein 8 fileout 8; filein = fopen(\"_in64\",'I',4,'B'); fileout = fopen(\"_out64\",'O',3,'B'); char= '20'x; do while(fread(filein)=0); length raw $4 ; do i=1 to 4; rc=fget(filein,char,1); substr(raw,i,1)=char; end; rc = fput(fileout, input(raw,$base64X4.)); rc =fwrite(fileout); end; rc = fclose(filein); rc = fclose(fileout); run; filename _in64 clear; filename _out64 clear; sasjs fs sync \u00b6 Will hash up a remote SAS filesystem, compare with local hashes, and deploy only the differences. Will also create the folder(s) on the remote server if necessary (if the SAS user account has the requisite permissions). Here's a demo video: Syntax \u00b6 sasjs fs sync <localFolder> <remoteFolder> -t targetName Can also be used without the arguments, taking values from the sasjsconfig.json file, eg: sasjs fs sync or sasjs fs sync -t myTarget Known Limitations \u00b6 The following issues exist with the current implementation - they do not affect the functionality (syncing local directory with remote) but we do plan to address them in a future release: If remoteFolder path is relative, or contains a tilde (eg ./somedir or ~/somedir ), the terminal response will incorrectly state that there were sync issues. This is due to path expansion affecting the comparison. In fact the files were deployed successfully. If a file is deleted locally, it will not be deleted remotely. This part has not been built yet. If a file in a subdirectory is renamed it will not be re-synced. This is due to hash compares at folder level being based only on file content. We will change the algorithm to include filenames when hashing folder content into a folder hash.","title":"sasjs fs"},{"location":"fs/#sasjs-fs","text":"The sasjs fs command allows users to manage a remote SAS (physical) filesystem from a local machine. No SSH or FTP accounts are necessary - the tool makes use of the APIs (Viya, SASjs Server ) or a SAS EBI STP runner . Not to be confused with: the logical SAS Folders (eg SAS Drive or Metadata BIP Tree), managed using the sasjs folder command . the regular sasjs compile command, which creates self-contained Jobs / Services / Tests that do not require a filesystem . It is also possible to use this feature natively within the SASjs VSCode Extension - https://github.com/sasjs/vscode-extension#directory-synchronisation .","title":"sasjs fs"},{"location":"fs/#prerequisites","text":"Before using this command, you will need to: install the SASjs CLI add a deployment target (for all operations except sasjs fs compile )","title":"Prerequisites"},{"location":"fs/#syntax","text":"sasjs fs <action> [additional arguments] Additional arguments may include: --target (alias -t ) - the target SAS Environment which contains the filesystem. Required attributes are serverUrl and serverType . If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file.","title":"Syntax"},{"location":"fs/#sasjs-fs-compile","text":"Used to generate a single SAS program that contains all the files (and subdirectories) of a given LOCAL folder. This program can be executed in any flavour of SAS to generate the files on the SAS server - simply set %let fsTarget=/your/target/folder; and run the program. To preserve encoding and special characters, as well as to enable the compilation of binary content, all files are base64 encoded.","title":"sasjs fs compile"},{"location":"fs/#syntax_1","text":"sasjs fs compile <localFolder> -o <programPath>","title":"Syntax"},{"location":"fs/#usage","text":"sasjs fs compile C:\\my\\project -o C:\\temp\\deployme.sas An extract from such a compiled program is shown below: %mf_mkdir(&fsTarget) filename _in64 temp lrecl=99999999; data _null_; file _in64; put 'ewogICIkc2NoZW1hIjogImh0dHBzOi8vY2xpLnNhc2pzLmlvL3Nhc2pzY29uZmlnLXNjaGVtYS5qc29uIiwKICAiZG9jQ29uZmlnIjogewogICAgImVuYWJsZUxpbmVhZ2UiOiB0cnVlLAogICAgImRveHlDb250ZW50IjogewogICAgICAicmVhZE1lIjogIi4uLy4uL1JFQURNRS5tZCIKICAg'@; put 'IH0sCiAgICAib3V0RGlyZWN0b3J5IjogInB1YmxpYy9kb2NzL3N0YXRpYy9zYXMiCiAgfSwKICAibWFjcm9Gb2xkZXJzIjogWyJzYXNqcy9tYWNyb3MiXSwKICAicHJvZ3JhbUZvbGRlcnMiOiBbXSwKICAic2VydmljZUNvbmZpZyI6IHsKICAgICJzZXJ2aWNlRm9sZGVycyI6IFsic2FzanMv'@; put 'c2VydmljZXMvY29tbW9uIiwgInNhc2pzL3NlcnZpY2VzL2ZpbGVzIl0sCiAgICAiaW5pdFByb2dyYW0iOiAic2FzanMvc2VydmljZXMvc2VydmljZWluaXQuc2FzIgogIH0sCiAgInN0cmVhbUNvbmZpZyI6IHsKICAgICJzdHJlYW1XZWIiOiB0cnVlLAogICAgInN0cmVhbVdlYkZvbGRlciI6'@; put 'ICJ3ZWJ2IiwKICAgICJ3ZWJTb3VyY2VQYXRoIjogImJ1aWxkIgogIH0sCiAgImRlZmF1bHRUYXJnZXQiOiAidml5YSIsCiAgInRhcmdldHMiOiBbCiAgICB7CiAgICAgICJuYW1lIjogInZpeWEiLAogICAgICAic2VydmVyVXJsIjogImh0dHBzOi8vYXp1cmV1c2UwMTEwNTkubXktdHJpYWxz'@; put 'LnNhcy5jb20vIiwKICAgICAgInNlcnZlclR5cGUiOiAiU0FTVklZQSIsCiAgICAgICJhcHBMb2MiOiAiL1B1YmxpYy9hcHAvcmVhY3Qtc2VlZC1hcHAiLAogICAgICAiY29udGV4dE5hbWUiOiAiU0FTIEpvYiBFeGVjdXRpb24gY29tcHV0ZSBjb250ZXh0IgogICAgfSwKICAgIHsKICAgICAg'@; put 'Im5hbWUiOiAic2VydmVyIiwKICAgICAgInNlcnZlclVybCI6ICJodHRwOi8vbG9jYWxob3N0OjUwMDAiLAogICAgICAic2VydmVyVHlwZSI6ICJTQVNKUyIsCiAgICAgICJodHRwc0FnZW50T3B0aW9ucyI6IHsKICAgICAgICAiYWxsb3dJbnNlY3VyZVJlcXVlc3RzIjogZmFsc2UKICAgICAg'@; put 'fSwKICAgICAgImFwcExvYyI6ICIvUHVibGljL2FwcC9yZWFjdC1zZWVkLWFwcCIsCiAgICAgICJkZXBsb3lDb25maWciOiB7CiAgICAgICAgImRlcGxveVNlcnZpY2VQYWNrIjogdHJ1ZSwKICAgICAgICAiZGVwbG95U2NyaXB0cyI6IFtdCiAgICAgIH0sCiAgICAgICJzdHJlYW1Db25maWci'@; put 'OiB7CiAgICAgICAgInN0cmVhbUxvZ28iOiAibG9nbzUxMi5wbmciLAogICAgICAgICJzdHJlYW1TZXJ2aWNlTmFtZSI6ICJSZWFjdCIsCiAgICAgICAgInN0cmVhbVdlYiI6IHRydWUsCiAgICAgICAgInN0cmVhbVdlYkZvbGRlciI6ICJ3ZWIiLAogICAgICAgICJ3ZWJTb3VyY2VQYXRoIjog'@; put 'ImJ1aWxkIiwKICAgICAgICAiYXNzZXRQYXRocyI6IFtdCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJuYW1lIjogInNhczkiLAogICAgICAic2VydmVyVHlwZSI6ICJTQVM5IiwKICAgICAgImFwcExvYyI6ICIvU2hhcmVkIERhdGEvc2FzanMvcmVhY3Qtc2VlZC1hcHAiLAogICAgICAi'@; put 'ZGVwbG95Q29uZmlnIjogewogICAgICAgICJkZXBsb3lTZXJ2aWNlUGFjayI6IHRydWUKICAgICAgfSwKICAgICAgInNlcnZlck5hbWUiOiAiU0FTQXBwIiwKICAgICAgInJlcG9zaXRvcnlOYW1lIjogIkZvdW5kYXRpb24iCiAgICB9CiAgXQp9Cg=='; run; filename _out64 \"&fsTarget/sasjsconfig.json\"; /* convert from base64 */ data _null_; length filein 8 fileout 8; filein = fopen(\"_in64\",'I',4,'B'); fileout = fopen(\"_out64\",'O',3,'B'); char= '20'x; do while(fread(filein)=0); length raw $4 ; do i=1 to 4; rc=fget(filein,char,1); substr(raw,i,1)=char; end; rc = fput(fileout, input(raw,$base64X4.)); rc =fwrite(fileout); end; rc = fclose(filein); rc = fclose(fileout); run; filename _in64 clear; filename _out64 clear;","title":"Usage"},{"location":"fs/#sasjs-fs-sync","text":"Will hash up a remote SAS filesystem, compare with local hashes, and deploy only the differences. Will also create the folder(s) on the remote server if necessary (if the SAS user account has the requisite permissions). Here's a demo video:","title":"sasjs fs sync"},{"location":"fs/#syntax_2","text":"sasjs fs sync <localFolder> <remoteFolder> -t targetName Can also be used without the arguments, taking values from the sasjsconfig.json file, eg: sasjs fs sync or sasjs fs sync -t myTarget","title":"Syntax"},{"location":"fs/#known-limitations","text":"The following issues exist with the current implementation - they do not affect the functionality (syncing local directory with remote) but we do plan to address them in a future release: If remoteFolder path is relative, or contains a tilde (eg ./somedir or ~/somedir ), the terminal response will incorrectly state that there were sync issues. This is due to path expansion affecting the comparison. In fact the files were deployed successfully. If a file is deleted locally, it will not be deleted remotely. This part has not been built yet. If a file in a subdirectory is renamed it will not be re-synced. This is due to hash compares at folder level being based only on file content. We will change the algorithm to include filenames when hashing folder content into a folder hash.","title":"Known Limitations"},{"location":"githooks/","text":"SASjs Git Hooks \u00b6 Coming soon!","title":"Git Hooks"},{"location":"githooks/#sasjs-git-hooks","text":"Coming soon!","title":"SASjs Git Hooks"},{"location":"installation/","text":"Installation \u00b6 The SASjs CLI is available on Node Package Manager . To make NPM available to your terminal, it is first necessary to install NodeJS. The NodeJS installation will vary depending on your OS, as detailed below. 1. NodeJS \u00b6 Windows \u00b6 If you only care about using the SASjs CLI then simply download NodeJS directly from the homepage: https://nodejs.org/en . We recommend you do NOT install chocolatey (leave the checkbox unchecked), unless you have a specific need for it. If you're a power user looking to play with different versions of NodeJS and you have admin rights on your machine, then NVM-Windows would be the better choice - available here: https://github.com/coreybutler/nvm-windows#installation--upgrades Mac / Linux \u00b6 We recommend using NVM instead of Node directly, as this does not require root permissions. curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash source ~/.bashrc nvm install --lts 2. SASjs CLI \u00b6 The CLI can now be installed using Node Package Manager (npm) as follows: npm i -g @sasjs/cli Upgrades \u00b6 Simply run npm i -g @sasjs/cli@latest to get the latest package. Note - this approach is not reliable if you are using NPM v6. We recommend that you use the latest version of NPM, for security reasons. To update NPM, run: npm i -g npm@latest","title":"Installation"},{"location":"installation/#installation","text":"The SASjs CLI is available on Node Package Manager . To make NPM available to your terminal, it is first necessary to install NodeJS. The NodeJS installation will vary depending on your OS, as detailed below.","title":"Installation"},{"location":"installation/#1-nodejs","text":"","title":"1. NodeJS"},{"location":"installation/#windows","text":"If you only care about using the SASjs CLI then simply download NodeJS directly from the homepage: https://nodejs.org/en . We recommend you do NOT install chocolatey (leave the checkbox unchecked), unless you have a specific need for it. If you're a power user looking to play with different versions of NodeJS and you have admin rights on your machine, then NVM-Windows would be the better choice - available here: https://github.com/coreybutler/nvm-windows#installation--upgrades","title":"Windows"},{"location":"installation/#mac-linux","text":"We recommend using NVM instead of Node directly, as this does not require root permissions. curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash source ~/.bashrc nvm install --lts","title":"Mac / Linux"},{"location":"installation/#2-sasjs-cli","text":"The CLI can now be installed using Node Package Manager (npm) as follows: npm i -g @sasjs/cli","title":"2. SASjs CLI"},{"location":"installation/#upgrades","text":"Simply run npm i -g @sasjs/cli@latest to get the latest package. Note - this approach is not reliable if you are using NPM v6. We recommend that you use the latest version of NPM, for security reasons. To update NPM, run: npm i -g npm@latest","title":"Upgrades"},{"location":"job/","text":"sasjs job \u00b6 The sasjs job command enables developers to perform operations on SAS Viya Jobs. Prerequisites \u00b6 Before using this command, you will need to: install the SASJS CLI add a deployment target. sasjs job execute \u00b6 Used to execute a job on the SAS server. Syntax \u00b6 sasjs job execute <job path> [additional arguments] Additional arguments may include: --log (alias -l ) - path where the log of the finished job will be saved (if used, -w is implied). --output (alias -o ) - path where output of the finished job execution will be saved. --source (alieas -s ) - Provide the path to an input JSON containing job variables, structured as follows: {\"macroVars\":{\"varname\":\"value\",\"var2\":\"val2\"}} --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. --verbose (alias -v ) - if present, CLI will log summary of every HTTP request/response. If set to 'bleached' (eg -v bleached ), CLI will log summary of every HTTP response without extra colors. The following flags are only relevant for serverType VIYA: --ignoreWarnings (alias -i ) - If present and return status only is provided, CLI will return status '0', when the job state is warning. --wait (alias -w ) - if present, CLI will wait for job completion. --returnStatusOnly (alias -r ) - deprecated Examples \u00b6 # run the job using the target defined in sasjs add sasjs job execute /Public/folder/someJob -l ./jobLog.log -o ./jobOutput.json -t myTarget This will create a session and run a SAS job. The log and output will be returned as files in the current directory. # create an input file with macro variables echo '{\"macroVars\":{\"myMacVar\":\"my macro value!\",\"macvar2\":\"another value\"}}' > sourcevars.json # execute the job with the above variables, against the default target sasjs job execute /Public/folder/someJob -l ./jobLog.log -s ./sourcevars.json","title":"sasjs job"},{"location":"job/#sasjs-job","text":"The sasjs job command enables developers to perform operations on SAS Viya Jobs.","title":"sasjs job"},{"location":"job/#prerequisites","text":"Before using this command, you will need to: install the SASJS CLI add a deployment target.","title":"Prerequisites"},{"location":"job/#sasjs-job-execute","text":"Used to execute a job on the SAS server.","title":"sasjs job execute"},{"location":"job/#syntax","text":"sasjs job execute <job path> [additional arguments] Additional arguments may include: --log (alias -l ) - path where the log of the finished job will be saved (if used, -w is implied). --output (alias -o ) - path where output of the finished job execution will be saved. --source (alieas -s ) - Provide the path to an input JSON containing job variables, structured as follows: {\"macroVars\":{\"varname\":\"value\",\"var2\":\"val2\"}} --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. --verbose (alias -v ) - if present, CLI will log summary of every HTTP request/response. If set to 'bleached' (eg -v bleached ), CLI will log summary of every HTTP response without extra colors. The following flags are only relevant for serverType VIYA: --ignoreWarnings (alias -i ) - If present and return status only is provided, CLI will return status '0', when the job state is warning. --wait (alias -w ) - if present, CLI will wait for job completion. --returnStatusOnly (alias -r ) - deprecated","title":"Syntax"},{"location":"job/#examples","text":"# run the job using the target defined in sasjs add sasjs job execute /Public/folder/someJob -l ./jobLog.log -o ./jobOutput.json -t myTarget This will create a session and run a SAS job. The log and output will be returned as files in the current directory. # create an input file with macro variables echo '{\"macroVars\":{\"myMacVar\":\"my macro value!\",\"macvar2\":\"another value\"}}' > sourcevars.json # execute the job with the above variables, against the default target sasjs job execute /Public/folder/someJob -l ./jobLog.log -s ./sourcevars.json","title":"Examples"},{"location":"lint/","text":"sasjs lint \u00b6 The sasjs lint command is used to identify issues such as embedded passwords, trailing spaces, sloppy indentation, missing program headers and more, in your SAS code. This means developers can spend less time on code reviews and formatting fixes, as well as preventing dangerous code, or code with hard-to-detect bugs from hitting production servers. Prerequisites \u00b6 Before using this command, you simply need to install the SASjs CLI. It is NOT necessary to configure a sasjs/sasjsconfig.json file - the sasjs lint command can be executed from anywhere - including from within a git hook. Configuration \u00b6 The lint settings are described here . The settings can be made in a project directory ( /your/project/.sasjslint ), with a fallback settings file in the home directory ( ~/.sasjslint ). If a setting is not defined in either the project or the home directory, then the default value is used. Linting is applied to all .sas files in all subfolders within the Project Directory. The rule for determining the Project Directory is as follows: If the current directory contains a .sasjslint file, then use the current directory Else search all parent directories for a .sasjslint file (ignoring the home directory) and if found, use that If no .sasjslint file is contained in any parent directories, then use the current directory For clarity, the Project Directory is printed to the console whenever running sasjs lint . Syntax \u00b6 sasjs lint <action> sasjs lint \u00b6 Syntax \u00b6 The command works as follows: sasjs lint Usage \u00b6 Simply run the command and the list of exceptions (along with line / column numbers) is shown in the console, eg: sasjs lint fix \u00b6 Syntax \u00b6 The command works as follows: sasjs lint fix Usage \u00b6 Simply run the command and the exceptions are fixed! The following rules are supported for 'autofix': noTrailingSpaces hasDoxygenHeader hasMacroNameInMend lowerCaseFileNames Usage in a GIT hook \u00b6 The sasjs lint command will return a non-zero exit code if any exceptions are found. A great way to prevent questionable code from ever hitting your GIT repo (let alone the production server) is to run the linter as part of a pre-commit hook. To configure this, there are two steps. First, add the following to the \"scripts\" section of your package.json file: \"prepare\": \"git rev-parse --git-dir && git config core.hooksPath ./.git-hooks || true\" Then, add the following to your .git-hooks/pre-commit file (see example ): #!/bin/bash # Ensure lint is passing LINT=`sasjs lint` if [[ \"$LINT\" != \"\u2714 All matched files use @sasjs/lint code style!\" ]]; then echo \"$LINT\" echo \"To commit in spite of these warnings, use the -n parameter.\" exit 1 fi If you run sasjs create SOMEPROJECT -t jobs you can check out a sample project with this hook already configured. Or, you can just clone this repo and run npm prepare . Further Resources: \u00b6 Using the linter on terminal Longer intro to sasjs lint Source repo: https://github.com/sasjs/lint Sponsorship & Contributions \u00b6 SASjs is an open source framework! Contributions are welcomed. If you would like to see a feature, because it would be useful in your project, but you don't have the requisite (TypeScript) experience - then how about you engage us to build it for you? Contact Allan Bowe for details.","title":"sasjs lint"},{"location":"lint/#sasjs-lint","text":"The sasjs lint command is used to identify issues such as embedded passwords, trailing spaces, sloppy indentation, missing program headers and more, in your SAS code. This means developers can spend less time on code reviews and formatting fixes, as well as preventing dangerous code, or code with hard-to-detect bugs from hitting production servers.","title":"sasjs lint"},{"location":"lint/#prerequisites","text":"Before using this command, you simply need to install the SASjs CLI. It is NOT necessary to configure a sasjs/sasjsconfig.json file - the sasjs lint command can be executed from anywhere - including from within a git hook.","title":"Prerequisites"},{"location":"lint/#configuration","text":"The lint settings are described here . The settings can be made in a project directory ( /your/project/.sasjslint ), with a fallback settings file in the home directory ( ~/.sasjslint ). If a setting is not defined in either the project or the home directory, then the default value is used. Linting is applied to all .sas files in all subfolders within the Project Directory. The rule for determining the Project Directory is as follows: If the current directory contains a .sasjslint file, then use the current directory Else search all parent directories for a .sasjslint file (ignoring the home directory) and if found, use that If no .sasjslint file is contained in any parent directories, then use the current directory For clarity, the Project Directory is printed to the console whenever running sasjs lint .","title":"Configuration"},{"location":"lint/#syntax","text":"sasjs lint <action>","title":"Syntax"},{"location":"lint/#sasjs-lint_1","text":"","title":"sasjs lint"},{"location":"lint/#syntax_1","text":"The command works as follows: sasjs lint","title":"Syntax"},{"location":"lint/#usage","text":"Simply run the command and the list of exceptions (along with line / column numbers) is shown in the console, eg:","title":"Usage"},{"location":"lint/#sasjs-lint-fix","text":"","title":"sasjs lint fix"},{"location":"lint/#syntax_2","text":"The command works as follows: sasjs lint fix","title":"Syntax"},{"location":"lint/#usage_1","text":"Simply run the command and the exceptions are fixed! The following rules are supported for 'autofix': noTrailingSpaces hasDoxygenHeader hasMacroNameInMend lowerCaseFileNames","title":"Usage"},{"location":"lint/#usage-in-a-git-hook","text":"The sasjs lint command will return a non-zero exit code if any exceptions are found. A great way to prevent questionable code from ever hitting your GIT repo (let alone the production server) is to run the linter as part of a pre-commit hook. To configure this, there are two steps. First, add the following to the \"scripts\" section of your package.json file: \"prepare\": \"git rev-parse --git-dir && git config core.hooksPath ./.git-hooks || true\" Then, add the following to your .git-hooks/pre-commit file (see example ): #!/bin/bash # Ensure lint is passing LINT=`sasjs lint` if [[ \"$LINT\" != \"\u2714 All matched files use @sasjs/lint code style!\" ]]; then echo \"$LINT\" echo \"To commit in spite of these warnings, use the -n parameter.\" exit 1 fi If you run sasjs create SOMEPROJECT -t jobs you can check out a sample project with this hook already configured. Or, you can just clone this repo and run npm prepare .","title":"Usage in a GIT hook"},{"location":"lint/#further-resources","text":"Using the linter on terminal Longer intro to sasjs lint Source repo: https://github.com/sasjs/lint","title":"Further Resources:"},{"location":"lint/#sponsorship-contributions","text":"SASjs is an open source framework! Contributions are welcomed. If you would like to see a feature, because it would be useful in your project, but you don't have the requisite (TypeScript) experience - then how about you engage us to build it for you? Contact Allan Bowe for details.","title":"Sponsorship &amp; Contributions"},{"location":"request/","text":"sasjs request \u00b6 The sasjs request command enables developers to call SASjs web services from the commandline. Prerequisites \u00b6 Before using this command, you will need to install the SASJS CLI and add a deployment target . sasjs request \u00b6 This will create a session and execute the relevant SAS service. The output will be returned as a file in the current directory ( output.json ). Syntax \u00b6 sasjs request <sasProgramPath> [additional arguments] sasProgramPath - if this has a leading slash (eg /Public/app/folder/servicename) then it must be the full path. If it is a relative path (eg path/servicename) then it will be pre-pended with the appLoc - defined in the config JSON file. Additional arguments may include: --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. --data (alias -d ) - (optional) The path to a json file containing the input data passed into the request. --config (alias -c ) - (optional) The path to a json file containting the config to be used when executing a request. --log (alias -l ) - Location in which to store the log file. If not provided AND current directory is a sasjs project, it will be saved in sasjsresults else in the current directory. --output (alias -o ) - Location to store the output file. If not provided AND current directory is a sasjs project, an output file will be saved in the sasjsresults folder else in current directory. data structure \u00b6 The input data is structured as follows: { \"tablewith2cols1row\": [{ \"col1\": \"val1\", \"col2\": 42 }], \"tablewith1col2rows\": [{ \"col\": \"row1\" }, { \"col\": \"row2\" }] } Examples \u00b6 # run a SAS Service without inputs, using the default target sasjs request /Public/app/myApp/common/appinit # run a SASjs web service with inputs and a config file sasjs request common/getdata -d ./dataFile.json -c ./configFile.json -t myTarget # run a SASjs web service with log and output files defined sasjs request /Public/app/myApp/common/appinit -l ./jobLog.log -o ./jobOutput.json","title":"sasjs request"},{"location":"request/#sasjs-request","text":"The sasjs request command enables developers to call SASjs web services from the commandline.","title":"sasjs request"},{"location":"request/#prerequisites","text":"Before using this command, you will need to install the SASJS CLI and add a deployment target .","title":"Prerequisites"},{"location":"request/#sasjs-request_1","text":"This will create a session and execute the relevant SAS service. The output will be returned as a file in the current directory ( output.json ).","title":"sasjs request"},{"location":"request/#syntax","text":"sasjs request <sasProgramPath> [additional arguments] sasProgramPath - if this has a leading slash (eg /Public/app/folder/servicename) then it must be the full path. If it is a relative path (eg path/servicename) then it will be pre-pended with the appLoc - defined in the config JSON file. Additional arguments may include: --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. --data (alias -d ) - (optional) The path to a json file containing the input data passed into the request. --config (alias -c ) - (optional) The path to a json file containting the config to be used when executing a request. --log (alias -l ) - Location in which to store the log file. If not provided AND current directory is a sasjs project, it will be saved in sasjsresults else in the current directory. --output (alias -o ) - Location to store the output file. If not provided AND current directory is a sasjs project, an output file will be saved in the sasjsresults folder else in current directory.","title":"Syntax"},{"location":"request/#data-structure","text":"The input data is structured as follows: { \"tablewith2cols1row\": [{ \"col1\": \"val1\", \"col2\": 42 }], \"tablewith1col2rows\": [{ \"col\": \"row1\" }, { \"col\": \"row2\" }] }","title":"data structure"},{"location":"request/#examples","text":"# run a SAS Service without inputs, using the default target sasjs request /Public/app/myApp/common/appinit # run a SASjs web service with inputs and a config file sasjs request common/getdata -d ./dataFile.json -c ./configFile.json -t myTarget # run a SASjs web service with log and output files defined sasjs request /Public/app/myApp/common/appinit -l ./jobLog.log -o ./jobOutput.json","title":"Examples"},{"location":"run/","text":"sasjs run \u00b6 The sasjs run command enables developers to submit SAS code for execution from the commandline. The log will be returned as a file in the current directory. The source file must have a \".sas\" extension. Note - an additional variable macro variable will be added by the adapter, with the value of the target appLoc and the filename (equivalent to %let _program=/My/AppLoc/runfilename.sas; ). This is actually added as a session variable, so will not be visible in the logs. Prerequisites \u00b6 Before using this command, you will need to install the SASJS CLI and add a deployment target . Syntax \u00b6 sasjs run <sourcecode> [additional arguments] <sourcecode> can be a local file path or a URL. Additional arguments may include: --log (alias -l ) - The full or relative (to the folder in which the command is invoked) path to the log file being created. If ommitted, the log will be created in the current directory, with a timestamp. --source (alias -s ) - Path to a JSON file that can be used to inject macro variables into the session. Useful for running existing programs in a \"job like\" fashion. The JSON file should have the following structure: {\"macroVars\": {\"varname\": \"value\", \"var2\": \"val2\"}} . This will result in the following code being injected into the session: %let varname=value; %let var2=val2; --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. --compile (alias -c ) - optional argument that is used to compile the program prior to execution. Useful for including dependent macros and includes. More info here . Using Github Urls \u00b6 If using a URL from github, be sure to link to the raw version of the file, eg: https://raw.githubusercontent.com/sasjs/core/main/base/mf_getattrc.sas As opposed to: https://github.com/sasjs/core/blob/main/base/mf_getattrc.sas If you click the links above you will see the difference. Whenever <sourcecode> begins with http:// or https:// we simply fetch the contents from the URL - so the raw value should be SAS code and nothing else. You can find the raw version by clicking on the 'raw' button when viewing the program on github (next to the 'blame' button) Examples \u00b6 Running some local SAS code: # create minimal SAS program cat > ./somecode.sas <<'EOL' %put hello from SASjs; EOL # run the SAS code on the target sasjs run somecode.sas -t myTarget Running some SAS code from github: sasjs run https://raw.githubusercontent.com/sasjs/template_jobs/master/includes/someprogram.sas -t viya Roadmap \u00b6 We plan to support the following: keeping sessions alive extracting items from the session If there are items you are looking for, or have problems / ideas, do raise an issue .","title":"sasjs run"},{"location":"run/#sasjs-run","text":"The sasjs run command enables developers to submit SAS code for execution from the commandline. The log will be returned as a file in the current directory. The source file must have a \".sas\" extension. Note - an additional variable macro variable will be added by the adapter, with the value of the target appLoc and the filename (equivalent to %let _program=/My/AppLoc/runfilename.sas; ). This is actually added as a session variable, so will not be visible in the logs.","title":"sasjs run"},{"location":"run/#prerequisites","text":"Before using this command, you will need to install the SASJS CLI and add a deployment target .","title":"Prerequisites"},{"location":"run/#syntax","text":"sasjs run <sourcecode> [additional arguments] <sourcecode> can be a local file path or a URL. Additional arguments may include: --log (alias -l ) - The full or relative (to the folder in which the command is invoked) path to the log file being created. If ommitted, the log will be created in the current directory, with a timestamp. --source (alias -s ) - Path to a JSON file that can be used to inject macro variables into the session. Useful for running existing programs in a \"job like\" fashion. The JSON file should have the following structure: {\"macroVars\": {\"varname\": \"value\", \"var2\": \"val2\"}} . This will result in the following code being injected into the session: %let varname=value; %let var2=val2; --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. --compile (alias -c ) - optional argument that is used to compile the program prior to execution. Useful for including dependent macros and includes. More info here .","title":"Syntax"},{"location":"run/#using-github-urls","text":"If using a URL from github, be sure to link to the raw version of the file, eg: https://raw.githubusercontent.com/sasjs/core/main/base/mf_getattrc.sas As opposed to: https://github.com/sasjs/core/blob/main/base/mf_getattrc.sas If you click the links above you will see the difference. Whenever <sourcecode> begins with http:// or https:// we simply fetch the contents from the URL - so the raw value should be SAS code and nothing else. You can find the raw version by clicking on the 'raw' button when viewing the program on github (next to the 'blame' button)","title":"Using Github Urls"},{"location":"run/#examples","text":"Running some local SAS code: # create minimal SAS program cat > ./somecode.sas <<'EOL' %put hello from SASjs; EOL # run the SAS code on the target sasjs run somecode.sas -t myTarget Running some SAS code from github: sasjs run https://raw.githubusercontent.com/sasjs/template_jobs/master/includes/someprogram.sas -t viya","title":"Examples"},{"location":"run/#roadmap","text":"We plan to support the following: keeping sessions alive extracting items from the session If there are items you are looking for, or have problems / ideas, do raise an issue .","title":"Roadmap"},{"location":"runner/","text":"Runner \u00b6 SAS 9 operations require the use of a \"runner\" for executing the SAS code generated by the CLI. For security, this runner is always stored in your home directory in metadata. To deploy the runner: /* import the macros */ filename mc url \"https://raw.githubusercontent.com/sasjs/core/main/all.sas\" ; %inc mc; /* create the runner */ filename ft15f001 temp; parmcards4; %macro sasjs_runner(); %if %symexist (_webin_fileref) %then %do ; %inc &_webin_fileref ; %end ; %mend sasjs_runner; %sasjs_runner () ;;;; %mm_createwebservice ( path=/User Folders/ &sysuserid /My Folder/sasjs, name=runner ) If your &sysuserid does not match your metadata user, then be sure to use your metadata user instead.","title":"SASjs Runner"},{"location":"runner/#runner","text":"SAS 9 operations require the use of a \"runner\" for executing the SAS code generated by the CLI. For security, this runner is always stored in your home directory in metadata. To deploy the runner: /* import the macros */ filename mc url \"https://raw.githubusercontent.com/sasjs/core/main/all.sas\" ; %inc mc; /* create the runner */ filename ft15f001 temp; parmcards4; %macro sasjs_runner(); %if %symexist (_webin_fileref) %then %do ; %inc &_webin_fileref ; %end ; %mend sasjs_runner; %sasjs_runner () ;;;; %mm_createwebservice ( path=/User Folders/ &sysuserid /My Folder/sasjs, name=runner ) If your &sysuserid does not match your metadata user, then be sure to use your metadata user instead.","title":"Runner"},{"location":"sasjsconfig/","text":"SASjs Configuration \u00b6 The SASjs Config file provides the settings for your SASjs project. It is divided between root-level (applies to all targets) and target level (specific to a deployment target) settings. Target level settings always override root settings. The SASjs config file can existing within a project (local file) or in your home directory (global). When running the SASjs CLI, a search is made within the current directory, then all parent directories, for a ./sasjs/sasjsconfig.json file. If none is found, then the user (home directory) config is used by default. If the project config is found, but the specified target is not found within it , then the user target will be searched also. The benefit of a global sasjsconfig is that you can use the settings anywhere on your filesystem (with that user account). The benefit of a local config file is that you can share the settings with other developers on your project. To view the below in full screen, click here .","title":"SASjs Config File"},{"location":"sasjsconfig/#sasjs-configuration","text":"The SASjs Config file provides the settings for your SASjs project. It is divided between root-level (applies to all targets) and target level (specific to a deployment target) settings. Target level settings always override root settings. The SASjs config file can existing within a project (local file) or in your home directory (global). When running the SASjs CLI, a search is made within the current directory, then all parent directories, for a ./sasjs/sasjsconfig.json file. If none is found, then the user (home directory) config is used by default. If the project config is found, but the specified target is not found within it , then the user target will be searched also. The benefit of a global sasjsconfig is that you can use the settings anywhere on your filesystem (with that user account). The benefit of a local config file is that you can share the settings with other developers on your project. To view the below in full screen, click here .","title":"SASjs Configuration"},{"location":"servicepack/","text":"sasjs servicepack \u00b6 The sasjs servicepack command allows administrators to deploy the backend services for a SASjs app using a CI/CD framework of choice. Currently only the deploy action is supported, in future the export and create options will be made available. If you are waiting on these, please raise a github issue . Prerequisites \u00b6 Before using this command, you will need to install the SASJS CLI and add a deployment target . Syntax \u00b6 sasjs servicepack <action> [additional arguments] Additional arguments may include: --source (alias -s ) - the source JSON file containin the services and folders. Used in the deploy action. --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. -f - used to f orce a deploy, eg even if the folders / services already exist (they will then be overwritten) Service Pack Structure \u00b6 The service pack structure is designed to provide the bare minimum for defining remote services. It is normally created as part of the sasjs build comand when the target serverType is VIYA. For info, it looks like this: { \"members\": [ { \"name\": \"services\", \"type\": \"folder\", \"members\": [ { \"name\": \"admin\", \"type\": \"folder\", \"members\": [ { \"name\": \"exportconfig\", \"type\": \"service\", \"code\": \"%put hello world;\" }] }] }] } sasjs servicepack deploy \u00b6 Used to deploy a servicepack to a Target. Note that the servicepack will be deployed to the appLoc defined in that target. Syntax \u00b6 sasjs servicepack deploy -s source.json -t target Usage \u00b6 # create minimal service pack cat > ./servicepack.json <<'EOL' { \"members\": [ { \"name\": \"services\", \"type\": \"folder\", \"members\": [ { \"name\": \"public\", \"type\": \"folder\", \"members\": [ { \"name\": \"hello\", \"type\": \"service\", \"code\": \"data _null_; file _webout; put 'Hello from SASjs';run;\" }] }] }] } EOL # deploy the service pack to the appLoc / server defined in the target (sasjs add) sasjs servicepack deploy -s ./servicepack.json -t myTarget","title":"sasjs servicepack"},{"location":"servicepack/#sasjs-servicepack","text":"The sasjs servicepack command allows administrators to deploy the backend services for a SASjs app using a CI/CD framework of choice. Currently only the deploy action is supported, in future the export and create options will be made available. If you are waiting on these, please raise a github issue .","title":"sasjs servicepack"},{"location":"servicepack/#prerequisites","text":"Before using this command, you will need to install the SASJS CLI and add a deployment target .","title":"Prerequisites"},{"location":"servicepack/#syntax","text":"sasjs servicepack <action> [additional arguments] Additional arguments may include: --source (alias -s ) - the source JSON file containin the services and folders. Used in the deploy action. --target (alias -t ) - the target environment in which to deploy the services. If not specified, default target will be used, mentioned in sasjsconfig.json . The target can exist either in the local project configuration or in the global .sasjsrc file. -f - used to f orce a deploy, eg even if the folders / services already exist (they will then be overwritten)","title":"Syntax"},{"location":"servicepack/#service-pack-structure","text":"The service pack structure is designed to provide the bare minimum for defining remote services. It is normally created as part of the sasjs build comand when the target serverType is VIYA. For info, it looks like this: { \"members\": [ { \"name\": \"services\", \"type\": \"folder\", \"members\": [ { \"name\": \"admin\", \"type\": \"folder\", \"members\": [ { \"name\": \"exportconfig\", \"type\": \"service\", \"code\": \"%put hello world;\" }] }] }] }","title":"Service Pack Structure"},{"location":"servicepack/#sasjs-servicepack-deploy","text":"Used to deploy a servicepack to a Target. Note that the servicepack will be deployed to the appLoc defined in that target.","title":"sasjs servicepack deploy"},{"location":"servicepack/#syntax_1","text":"sasjs servicepack deploy -s source.json -t target","title":"Syntax"},{"location":"servicepack/#usage","text":"# create minimal service pack cat > ./servicepack.json <<'EOL' { \"members\": [ { \"name\": \"services\", \"type\": \"folder\", \"members\": [ { \"name\": \"public\", \"type\": \"folder\", \"members\": [ { \"name\": \"hello\", \"type\": \"service\", \"code\": \"data _null_; file _webout; put 'Hello from SASjs';run;\" }] }] }] } EOL # deploy the service pack to the appLoc / server defined in the target (sasjs add) sasjs servicepack deploy -s ./servicepack.json -t myTarget","title":"Usage"},{"location":"snippets/","text":"sasjs snippets \u00b6 The sasjs snippets command generates VS Code snippets from any SAS macros contained in the folders (or subfolders) listed in the macroFolders array of the sasjs/sasjsconfig.json file. If macroFolders is defined at both configuration and target level, the two arrays will be merged in a single array of macro folders. Macros are those that fit the \"$(macroname).sas\" pattern - tests (such as macroname.test.sas or macroname.test.1.sas) are excluded, as are files with a non \".sas\" extension. Note - snippets are generated from the filename and doxygen header content, not the SAS code itself. Syntax \u00b6 sasjs snippets --outDirectory <folderPath> --target <targetName> --outDirectory (alias -o ) - optional output directory. If not present, the snippets will be saved to the sasjsresults/sasjs-macro-snippets.json file. --target (alias -t ) - optional SASjs target that should be used. Generate Snippets File \u00b6 Consider the file name my/macros/example.sas : /** @file @brief An example macro @details prints an arbitrary message to the log @param msg The message to be printed @author Allan Bowe **/ %macro example(msg); %let testvar= %sysfunc ( ranuni( 0 )) ; data work . example; msg= symget( 'msg' ); putlog msg= ; run; %mend example ; Assuming a sasjs/sasjsconfig.json file as follows: { \"$schema\" : \"https://cli.sasjs.io/sasjsconfig-schema.json\" , \"macroFolders\" : [ \"my/macros\" ] } Simply run the sasjs snippets command within the SASjs project, and the following file will be written to sasjsresults/sasjs-macro-snippets.json : { \"example\" : { \"prefix\" : \"%example\" , \"body\" : \"%example($1)\" , \"description\" : [ \"An example macro\" , \"\\r\" , \"Params:\\r\" , \"-msg The message to be printed\\r\" ] } } Notice that the doxygen @brief value has been placed at the beginning of the description, and @param has been put to the Params section. The file name has been used to populate the prefix and body of the VS Code snippet, and placeholders are also created in the body . Import Snippets to VS Code \u00b6 In order to import the generated VS Code snippets file please follow these steps: Open Command Pallet by pressing F1 (unix) or ctrl+shift+P (windows). Type Snippets: Configure User Snippets . Choose sas.json . Copy everything from the file generated by sasjs snippets command and paste it into sas.json . Save sas.json Snippets should be available in any .sas file by typing %<name of the snippet> ( %example for the snippet from an example provided above).","title":"sasjs snippets"},{"location":"snippets/#sasjs-snippets","text":"The sasjs snippets command generates VS Code snippets from any SAS macros contained in the folders (or subfolders) listed in the macroFolders array of the sasjs/sasjsconfig.json file. If macroFolders is defined at both configuration and target level, the two arrays will be merged in a single array of macro folders. Macros are those that fit the \"$(macroname).sas\" pattern - tests (such as macroname.test.sas or macroname.test.1.sas) are excluded, as are files with a non \".sas\" extension. Note - snippets are generated from the filename and doxygen header content, not the SAS code itself.","title":"sasjs snippets"},{"location":"snippets/#syntax","text":"sasjs snippets --outDirectory <folderPath> --target <targetName> --outDirectory (alias -o ) - optional output directory. If not present, the snippets will be saved to the sasjsresults/sasjs-macro-snippets.json file. --target (alias -t ) - optional SASjs target that should be used.","title":"Syntax"},{"location":"snippets/#generate-snippets-file","text":"Consider the file name my/macros/example.sas : /** @file @brief An example macro @details prints an arbitrary message to the log @param msg The message to be printed @author Allan Bowe **/ %macro example(msg); %let testvar= %sysfunc ( ranuni( 0 )) ; data work . example; msg= symget( 'msg' ); putlog msg= ; run; %mend example ; Assuming a sasjs/sasjsconfig.json file as follows: { \"$schema\" : \"https://cli.sasjs.io/sasjsconfig-schema.json\" , \"macroFolders\" : [ \"my/macros\" ] } Simply run the sasjs snippets command within the SASjs project, and the following file will be written to sasjsresults/sasjs-macro-snippets.json : { \"example\" : { \"prefix\" : \"%example\" , \"body\" : \"%example($1)\" , \"description\" : [ \"An example macro\" , \"\\r\" , \"Params:\\r\" , \"-msg The message to be printed\\r\" ] } } Notice that the doxygen @brief value has been placed at the beginning of the description, and @param has been put to the Params section. The file name has been used to populate the prefix and body of the VS Code snippet, and placeholders are also created in the body .","title":"Generate Snippets File"},{"location":"snippets/#import-snippets-to-vs-code","text":"In order to import the generated VS Code snippets file please follow these steps: Open Command Pallet by pressing F1 (unix) or ctrl+shift+P (windows). Type Snippets: Configure User Snippets . Choose sas.json . Copy everything from the file generated by sasjs snippets command and paste it into sas.json . Save sas.json Snippets should be available in any .sas file by typing %<name of the snippet> ( %example for the snippet from an example provided above).","title":"Import Snippets to VS Code"},{"location":"test/","text":"sasjs test \u00b6 The sasjs test command triggers deployed SAS unit tests for execution, and collects the test results in JSON, JUnit XML, LCOV and CSV formats. Results are also displayed in the console, as follows: Tests are compiled & deployed as services (STPs in SAS 9, Jobs in Viya, Stored Programs in SASjs/server). In this way, every test is completely isolated with it's own SAS session . To create a test, simply create a file with the same name as the Job / Service / Macro being tested, but with a .test.sas extension. If you have multiple tests, you can add a .test.[integer].sas extension, and the tests will proceed according to the integers provided. You can send back one or more test results in a single program by creating a table called work.test_results with the following entries: TEST_DESCRIPTION:$256 TEST_RESULT:$4 TEST_COMMENTS:$256 Some description PASS Some run related comment Another test description FAIL some explanation of the failure The results should be sent back using the following macros (which could be in your termProgram entry): /* do some tests */ data some sas tests; set whatever you like ; run; /* create a test_results table */ data work . test_results; /* mandatory values */ test_description= \"some description\" ; test_result= \"PASS\" ; /* or FAIL */ /* optional value */ test_comments= \"We did this & that happened\" ; output ; run; /* send it back with the precompiled webout macro */ %webout (OPEN) %webout (OBJ, TEST_RESULTS) %webout (CLOSE) Examples of tests for SAS Macros are available in the SASjs/CORE library . There are also a series of assertion macros available. Test Locations \u00b6 Tests will only be compiled if they exist in a folder listed in one of the following sasjsconfig arrays: macroFolders jobFolders serviceFolders Syntax \u00b6 sasjs test <filteringString> --source <testFlowPath> --outDirectory <folderPath> -t <targetName> --ignoreFail Providing filteringString is optional. If not present, all tests mentioned in test flow file will be executed. Providing source flag is optional. If not present, CLI will use test flow located at sasjsbuild/testFlow.json (created when running sasjs build ). Providing outDirectory flag is optional. If not present, CLI will save outputs into the temporary sasjsresults folder. Providing ignore fail (--ignoreFail or -iF) flag is optional. If present CLI will return exit code 0 even if tests are failing. Useful when the requirement is not to make CI Pipeline fail.` Examples \u00b6 Execute all tests for the default target: sasjs test Execute all tests in the macros folder: sasjs test /macros/ Execute all tests starting with \"mv_\" and save the output in 'myresults' folder sasjs test mv_ --outDirectory /somedir/myresults Prevent command fail (for example in CI Pipeline): sasjs test --ignoreFail Configuration \u00b6 Test configuration can be provided at root or target level. Configuration example: \"testConfig\" : { \"initProgram\" : \"sasjs/tests/testinit.sas\" , \"termProgram\" : \"sasjs/tests/testterm.sas\" , \"macroVars\" : { \"testVar\" : \"testValue\" }, \"testSetUp\" : \"sasjs/tests/testsetup.sas\" , \"testTearDown\" : \"sasjs/tests/testteardown.sas\" } testSetUp will be executed prior to all tests testTearDown will be executed after all tests have finished initProgram is inserted at the start of every test termProgram is inserted at the end of every test macroVars are defined at the start of every test File Name Convention \u00b6 Only files names that match following pattern will be considered as tests. Pattern: [filename].test<.integer>.sas Examples: some_service.test.sas some_job.test.0.sas some_job.test.1.sas Providing a test integer is optional, if provided, the tests will be executed accordingly to numerical order - eg some_job.test.0.sas first and some_job.test.1.sas second. Coverage \u00b6 A SAS Service, Job or Macro is considered covered if there is a test file with the same filename , for example: \u251c\u2500\u2500 some_service.sas \u251c\u2500\u2500 some_service.test.sas \u251c\u2500\u2500 some_job.sas \u2514\u2500\u2500 some_macro.test.sas In the example above, some_service will be considered covered, some_job will be considered not covered and some_macro.test will be considered as a standalone test. Overall coverage is displayed, along with a group summary for Jobs, Services and Macros. Note We are planning a more 'intelligent' coverage system that can detect whether a macro / servivce / job was executed as part of the test suite. If this would be helpful to your project, do get in touch ! Test Body \u00b6 An example of a test that provides a result: data work . test_results; test_description= \"some description\" ; test_result= \"PASS\" ; test_comments= \"We did this & that happened\" ; output ; run; %webout (OPEN) %webout (OBJ, test_results) %webout (CLOSE) Providing the test_results table with a test_result variable is required, in order for the frontend to determine if the test is a PASS or FAIL . The webout() macro definition will be deployed as precode in the compiled test, and is essentially a wrapper for mm_webout.sas or mv_webout.sas according the serverType of the target . Test Flow \u00b6 SAS unit tests will be executed one after another. Execution order is described in sasjsbuild/testFlow.json which is created as part of compilation process ( sasjs compile ). Test Results \u00b6 By default test results will be saved in the sasjsresults folder. An example of sasjsresults folder structure: \u251c\u2500\u2500 logs \u2502 \u251c\u2500\u2500 macros_some_macro.test.1.log \u2502 \u251c\u2500\u2500 macros_some_macro.test.log \u2502 \u251c\u2500\u2500 services_some_service.test.log \u2502 \u251c\u2500\u2500 jobs_some_job.test.log \u2502 \u251c\u2500\u2500 testteardown.log \u2502 \u2514\u2500\u2500 testsetup.log \u251c\u2500\u2500 testResults.csv \u2514\u2500\u2500 testResults.json \u2514\u2500\u2500 testResults.xml Results are saved in CSV, JSON and JUnit XML formats. Assertion Macros \u00b6 A number of ready made assertion macros are available in the SASjs Core library: mp_assert - generic assertion mp_assertcols - Asserts the existence (or not) of certain columns mp_assertcolvals - Asserts the existence (or not) of particular column values mp_assertdsobs - Asserts the existence (or not) of dataset observations mp_assertscope - Compares before/after to detect scope leakage in a SAS Macro Running SAS Tests with SASjs \u00b6 In order to run tests, take the following steps: Provide tests configuration (testConfig) in the sasjs/sasjsconfig.json file Create test files in services, jobs or macro folders (with .test.sas extension). Execute sasjs cbd -t <targetName> to compile and deploy the tests as isolated SAS web services Execute sasjs test -t <targetName> Visit the local sasjsresults folder to review results. To assist with debugging, all logs are captured, and we generate a URL so that you can easily click and re-run any particular individual test. CSV Format: JSON Format: JUnit XML Format: Console Output: Demo Video \u00b6 A demonstration of sasjs test by the developer, Yury Shkoda was provided at a Sasensei SID event in July 2021 - available below.","title":"sasjs test"},{"location":"test/#sasjs-test","text":"The sasjs test command triggers deployed SAS unit tests for execution, and collects the test results in JSON, JUnit XML, LCOV and CSV formats. Results are also displayed in the console, as follows: Tests are compiled & deployed as services (STPs in SAS 9, Jobs in Viya, Stored Programs in SASjs/server). In this way, every test is completely isolated with it's own SAS session . To create a test, simply create a file with the same name as the Job / Service / Macro being tested, but with a .test.sas extension. If you have multiple tests, you can add a .test.[integer].sas extension, and the tests will proceed according to the integers provided. You can send back one or more test results in a single program by creating a table called work.test_results with the following entries: TEST_DESCRIPTION:$256 TEST_RESULT:$4 TEST_COMMENTS:$256 Some description PASS Some run related comment Another test description FAIL some explanation of the failure The results should be sent back using the following macros (which could be in your termProgram entry): /* do some tests */ data some sas tests; set whatever you like ; run; /* create a test_results table */ data work . test_results; /* mandatory values */ test_description= \"some description\" ; test_result= \"PASS\" ; /* or FAIL */ /* optional value */ test_comments= \"We did this & that happened\" ; output ; run; /* send it back with the precompiled webout macro */ %webout (OPEN) %webout (OBJ, TEST_RESULTS) %webout (CLOSE) Examples of tests for SAS Macros are available in the SASjs/CORE library . There are also a series of assertion macros available.","title":"sasjs test"},{"location":"test/#test-locations","text":"Tests will only be compiled if they exist in a folder listed in one of the following sasjsconfig arrays: macroFolders jobFolders serviceFolders","title":"Test Locations"},{"location":"test/#syntax","text":"sasjs test <filteringString> --source <testFlowPath> --outDirectory <folderPath> -t <targetName> --ignoreFail Providing filteringString is optional. If not present, all tests mentioned in test flow file will be executed. Providing source flag is optional. If not present, CLI will use test flow located at sasjsbuild/testFlow.json (created when running sasjs build ). Providing outDirectory flag is optional. If not present, CLI will save outputs into the temporary sasjsresults folder. Providing ignore fail (--ignoreFail or -iF) flag is optional. If present CLI will return exit code 0 even if tests are failing. Useful when the requirement is not to make CI Pipeline fail.`","title":"Syntax"},{"location":"test/#examples","text":"Execute all tests for the default target: sasjs test Execute all tests in the macros folder: sasjs test /macros/ Execute all tests starting with \"mv_\" and save the output in 'myresults' folder sasjs test mv_ --outDirectory /somedir/myresults Prevent command fail (for example in CI Pipeline): sasjs test --ignoreFail","title":"Examples"},{"location":"test/#configuration","text":"Test configuration can be provided at root or target level. Configuration example: \"testConfig\" : { \"initProgram\" : \"sasjs/tests/testinit.sas\" , \"termProgram\" : \"sasjs/tests/testterm.sas\" , \"macroVars\" : { \"testVar\" : \"testValue\" }, \"testSetUp\" : \"sasjs/tests/testsetup.sas\" , \"testTearDown\" : \"sasjs/tests/testteardown.sas\" } testSetUp will be executed prior to all tests testTearDown will be executed after all tests have finished initProgram is inserted at the start of every test termProgram is inserted at the end of every test macroVars are defined at the start of every test","title":"Configuration"},{"location":"test/#file-name-convention","text":"Only files names that match following pattern will be considered as tests. Pattern: [filename].test<.integer>.sas Examples: some_service.test.sas some_job.test.0.sas some_job.test.1.sas Providing a test integer is optional, if provided, the tests will be executed accordingly to numerical order - eg some_job.test.0.sas first and some_job.test.1.sas second.","title":"File Name Convention"},{"location":"test/#coverage","text":"A SAS Service, Job or Macro is considered covered if there is a test file with the same filename , for example: \u251c\u2500\u2500 some_service.sas \u251c\u2500\u2500 some_service.test.sas \u251c\u2500\u2500 some_job.sas \u2514\u2500\u2500 some_macro.test.sas In the example above, some_service will be considered covered, some_job will be considered not covered and some_macro.test will be considered as a standalone test. Overall coverage is displayed, along with a group summary for Jobs, Services and Macros. Note We are planning a more 'intelligent' coverage system that can detect whether a macro / servivce / job was executed as part of the test suite. If this would be helpful to your project, do get in touch !","title":"Coverage"},{"location":"test/#test-body","text":"An example of a test that provides a result: data work . test_results; test_description= \"some description\" ; test_result= \"PASS\" ; test_comments= \"We did this & that happened\" ; output ; run; %webout (OPEN) %webout (OBJ, test_results) %webout (CLOSE) Providing the test_results table with a test_result variable is required, in order for the frontend to determine if the test is a PASS or FAIL . The webout() macro definition will be deployed as precode in the compiled test, and is essentially a wrapper for mm_webout.sas or mv_webout.sas according the serverType of the target .","title":"Test Body"},{"location":"test/#test-flow","text":"SAS unit tests will be executed one after another. Execution order is described in sasjsbuild/testFlow.json which is created as part of compilation process ( sasjs compile ).","title":"Test Flow"},{"location":"test/#test-results","text":"By default test results will be saved in the sasjsresults folder. An example of sasjsresults folder structure: \u251c\u2500\u2500 logs \u2502 \u251c\u2500\u2500 macros_some_macro.test.1.log \u2502 \u251c\u2500\u2500 macros_some_macro.test.log \u2502 \u251c\u2500\u2500 services_some_service.test.log \u2502 \u251c\u2500\u2500 jobs_some_job.test.log \u2502 \u251c\u2500\u2500 testteardown.log \u2502 \u2514\u2500\u2500 testsetup.log \u251c\u2500\u2500 testResults.csv \u2514\u2500\u2500 testResults.json \u2514\u2500\u2500 testResults.xml Results are saved in CSV, JSON and JUnit XML formats.","title":"Test Results"},{"location":"test/#assertion-macros","text":"A number of ready made assertion macros are available in the SASjs Core library: mp_assert - generic assertion mp_assertcols - Asserts the existence (or not) of certain columns mp_assertcolvals - Asserts the existence (or not) of particular column values mp_assertdsobs - Asserts the existence (or not) of dataset observations mp_assertscope - Compares before/after to detect scope leakage in a SAS Macro","title":"Assertion Macros"},{"location":"test/#running-sas-tests-with-sasjs","text":"In order to run tests, take the following steps: Provide tests configuration (testConfig) in the sasjs/sasjsconfig.json file Create test files in services, jobs or macro folders (with .test.sas extension). Execute sasjs cbd -t <targetName> to compile and deploy the tests as isolated SAS web services Execute sasjs test -t <targetName> Visit the local sasjsresults folder to review results. To assist with debugging, all logs are captured, and we generate a URL so that you can easily click and re-run any particular individual test. CSV Format: JSON Format: JUnit XML Format: Console Output:","title":"Running SAS Tests with SASjs"},{"location":"test/#demo-video","text":"A demonstration of sasjs test by the developer, Yury Shkoda was provided at a Sasensei SID event in July 2021 - available below.","title":"Demo Video"}]}